// Code generated by counterfeiter. DO NOT EDIT.
package workflowfakes

import (
	"context"
	"sync"

	"github.com/Linkinlog/LeafList/internal/models"
	"github.com/Linkinlog/LeafList/internal/workflow"
)

type FakeManager struct {
	CannabinoidsStub        func(string, string) ([]*models.Cannabinoid, error)
	cannabinoidsMutex       sync.RWMutex
	cannabinoidsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	cannabinoidsReturns struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	cannabinoidsReturnsOnCall map[int]struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	CategoriesStub        func(string, string) ([]*models.Category, error)
	categoriesMutex       sync.RWMutex
	categoriesArgsForCall []struct {
		arg1 string
		arg2 string
	}
	categoriesReturns struct {
		result1 []*models.Category
		result2 error
	}
	categoriesReturnsOnCall map[int]struct {
		result1 []*models.Category
		result2 error
	}
	LogErrorStub        func(error, context.Context)
	logErrorMutex       sync.RWMutex
	logErrorArgsForCall []struct {
		arg1 error
		arg2 context.Context
	}
	MenuStub        func(string, string) (*models.Dispensary, error)
	menuMutex       sync.RWMutex
	menuArgsForCall []struct {
		arg1 string
		arg2 string
	}
	menuReturns struct {
		result1 *models.Dispensary
		result2 error
	}
	menuReturnsOnCall map[int]struct {
		result1 *models.Dispensary
		result2 error
	}
	MenusStub        func(string) ([]*models.Dispensary, error)
	menusMutex       sync.RWMutex
	menusArgsForCall []struct {
		arg1 string
	}
	menusReturns struct {
		result1 []*models.Dispensary
		result2 error
	}
	menusReturnsOnCall map[int]struct {
		result1 []*models.Dispensary
		result2 error
	}
	OffersStub        func(string, string) ([]*models.Offer, error)
	offersMutex       sync.RWMutex
	offersArgsForCall []struct {
		arg1 string
		arg2 string
	}
	offersReturns struct {
		result1 []*models.Offer
		result2 error
	}
	offersReturnsOnCall map[int]struct {
		result1 []*models.Offer
		result2 error
	}
	ProductStub        func(string, string, string) (*models.Product, error)
	productMutex       sync.RWMutex
	productArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	productReturns struct {
		result1 *models.Product
		result2 error
	}
	productReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	ProductsStub        func(string, string) ([]*models.Product, error)
	productsMutex       sync.RWMutex
	productsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	productsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForCategoryStub        func(string, string, models.Category) ([]*models.Product, error)
	productsForCategoryMutex       sync.RWMutex
	productsForCategoryArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 models.Category
	}
	productsForCategoryReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForCategoryReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	TerpenesStub        func(string, string) ([]*models.Terpene, error)
	terpenesMutex       sync.RWMutex
	terpenesArgsForCall []struct {
		arg1 string
		arg2 string
	}
	terpenesReturns struct {
		result1 []*models.Terpene
		result2 error
	}
	terpenesReturnsOnCall map[int]struct {
		result1 []*models.Terpene
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) Cannabinoids(arg1 string, arg2 string) ([]*models.Cannabinoid, error) {
	fake.cannabinoidsMutex.Lock()
	ret, specificReturn := fake.cannabinoidsReturnsOnCall[len(fake.cannabinoidsArgsForCall)]
	fake.cannabinoidsArgsForCall = append(fake.cannabinoidsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CannabinoidsStub
	fakeReturns := fake.cannabinoidsReturns
	fake.recordInvocation("Cannabinoids", []interface{}{arg1, arg2})
	fake.cannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) CannabinoidsCallCount() int {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	return len(fake.cannabinoidsArgsForCall)
}

func (fake *FakeManager) CannabinoidsCalls(stub func(string, string) ([]*models.Cannabinoid, error)) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = stub
}

func (fake *FakeManager) CannabinoidsArgsForCall(i int) (string, string) {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	argsForCall := fake.cannabinoidsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) CannabinoidsReturns(result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	fake.cannabinoidsReturns = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CannabinoidsReturnsOnCall(i int, result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	if fake.cannabinoidsReturnsOnCall == nil {
		fake.cannabinoidsReturnsOnCall = make(map[int]struct {
			result1 []*models.Cannabinoid
			result2 error
		})
	}
	fake.cannabinoidsReturnsOnCall[i] = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Categories(arg1 string, arg2 string) ([]*models.Category, error) {
	fake.categoriesMutex.Lock()
	ret, specificReturn := fake.categoriesReturnsOnCall[len(fake.categoriesArgsForCall)]
	fake.categoriesArgsForCall = append(fake.categoriesArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CategoriesStub
	fakeReturns := fake.categoriesReturns
	fake.recordInvocation("Categories", []interface{}{arg1, arg2})
	fake.categoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) CategoriesCallCount() int {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	return len(fake.categoriesArgsForCall)
}

func (fake *FakeManager) CategoriesCalls(stub func(string, string) ([]*models.Category, error)) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = stub
}

func (fake *FakeManager) CategoriesArgsForCall(i int) (string, string) {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	argsForCall := fake.categoriesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) CategoriesReturns(result1 []*models.Category, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	fake.categoriesReturns = struct {
		result1 []*models.Category
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CategoriesReturnsOnCall(i int, result1 []*models.Category, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	if fake.categoriesReturnsOnCall == nil {
		fake.categoriesReturnsOnCall = make(map[int]struct {
			result1 []*models.Category
			result2 error
		})
	}
	fake.categoriesReturnsOnCall[i] = struct {
		result1 []*models.Category
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) LogError(arg1 error, arg2 context.Context) {
	fake.logErrorMutex.Lock()
	fake.logErrorArgsForCall = append(fake.logErrorArgsForCall, struct {
		arg1 error
		arg2 context.Context
	}{arg1, arg2})
	stub := fake.LogErrorStub
	fake.recordInvocation("LogError", []interface{}{arg1, arg2})
	fake.logErrorMutex.Unlock()
	if stub != nil {
		fake.LogErrorStub(arg1, arg2)
	}
}

func (fake *FakeManager) LogErrorCallCount() int {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	return len(fake.logErrorArgsForCall)
}

func (fake *FakeManager) LogErrorCalls(stub func(error, context.Context)) {
	fake.logErrorMutex.Lock()
	defer fake.logErrorMutex.Unlock()
	fake.LogErrorStub = stub
}

func (fake *FakeManager) LogErrorArgsForCall(i int) (error, context.Context) {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	argsForCall := fake.logErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) Menu(arg1 string, arg2 string) (*models.Dispensary, error) {
	fake.menuMutex.Lock()
	ret, specificReturn := fake.menuReturnsOnCall[len(fake.menuArgsForCall)]
	fake.menuArgsForCall = append(fake.menuArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.MenuStub
	fakeReturns := fake.menuReturns
	fake.recordInvocation("Menu", []interface{}{arg1, arg2})
	fake.menuMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) MenuCallCount() int {
	fake.menuMutex.RLock()
	defer fake.menuMutex.RUnlock()
	return len(fake.menuArgsForCall)
}

func (fake *FakeManager) MenuCalls(stub func(string, string) (*models.Dispensary, error)) {
	fake.menuMutex.Lock()
	defer fake.menuMutex.Unlock()
	fake.MenuStub = stub
}

func (fake *FakeManager) MenuArgsForCall(i int) (string, string) {
	fake.menuMutex.RLock()
	defer fake.menuMutex.RUnlock()
	argsForCall := fake.menuArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) MenuReturns(result1 *models.Dispensary, result2 error) {
	fake.menuMutex.Lock()
	defer fake.menuMutex.Unlock()
	fake.MenuStub = nil
	fake.menuReturns = struct {
		result1 *models.Dispensary
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) MenuReturnsOnCall(i int, result1 *models.Dispensary, result2 error) {
	fake.menuMutex.Lock()
	defer fake.menuMutex.Unlock()
	fake.MenuStub = nil
	if fake.menuReturnsOnCall == nil {
		fake.menuReturnsOnCall = make(map[int]struct {
			result1 *models.Dispensary
			result2 error
		})
	}
	fake.menuReturnsOnCall[i] = struct {
		result1 *models.Dispensary
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Menus(arg1 string) ([]*models.Dispensary, error) {
	fake.menusMutex.Lock()
	ret, specificReturn := fake.menusReturnsOnCall[len(fake.menusArgsForCall)]
	fake.menusArgsForCall = append(fake.menusArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.MenusStub
	fakeReturns := fake.menusReturns
	fake.recordInvocation("Menus", []interface{}{arg1})
	fake.menusMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) MenusCallCount() int {
	fake.menusMutex.RLock()
	defer fake.menusMutex.RUnlock()
	return len(fake.menusArgsForCall)
}

func (fake *FakeManager) MenusCalls(stub func(string) ([]*models.Dispensary, error)) {
	fake.menusMutex.Lock()
	defer fake.menusMutex.Unlock()
	fake.MenusStub = stub
}

func (fake *FakeManager) MenusArgsForCall(i int) string {
	fake.menusMutex.RLock()
	defer fake.menusMutex.RUnlock()
	argsForCall := fake.menusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) MenusReturns(result1 []*models.Dispensary, result2 error) {
	fake.menusMutex.Lock()
	defer fake.menusMutex.Unlock()
	fake.MenusStub = nil
	fake.menusReturns = struct {
		result1 []*models.Dispensary
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) MenusReturnsOnCall(i int, result1 []*models.Dispensary, result2 error) {
	fake.menusMutex.Lock()
	defer fake.menusMutex.Unlock()
	fake.MenusStub = nil
	if fake.menusReturnsOnCall == nil {
		fake.menusReturnsOnCall = make(map[int]struct {
			result1 []*models.Dispensary
			result2 error
		})
	}
	fake.menusReturnsOnCall[i] = struct {
		result1 []*models.Dispensary
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Offers(arg1 string, arg2 string) ([]*models.Offer, error) {
	fake.offersMutex.Lock()
	ret, specificReturn := fake.offersReturnsOnCall[len(fake.offersArgsForCall)]
	fake.offersArgsForCall = append(fake.offersArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.OffersStub
	fakeReturns := fake.offersReturns
	fake.recordInvocation("Offers", []interface{}{arg1, arg2})
	fake.offersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) OffersCallCount() int {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	return len(fake.offersArgsForCall)
}

func (fake *FakeManager) OffersCalls(stub func(string, string) ([]*models.Offer, error)) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = stub
}

func (fake *FakeManager) OffersArgsForCall(i int) (string, string) {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	argsForCall := fake.offersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) OffersReturns(result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	fake.offersReturns = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) OffersReturnsOnCall(i int, result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	if fake.offersReturnsOnCall == nil {
		fake.offersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
			result2 error
		})
	}
	fake.offersReturnsOnCall[i] = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Product(arg1 string, arg2 string, arg3 string) (*models.Product, error) {
	fake.productMutex.Lock()
	ret, specificReturn := fake.productReturnsOnCall[len(fake.productArgsForCall)]
	fake.productArgsForCall = append(fake.productArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ProductStub
	fakeReturns := fake.productReturns
	fake.recordInvocation("Product", []interface{}{arg1, arg2, arg3})
	fake.productMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ProductCallCount() int {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	return len(fake.productArgsForCall)
}

func (fake *FakeManager) ProductCalls(stub func(string, string, string) (*models.Product, error)) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = stub
}

func (fake *FakeManager) ProductArgsForCall(i int) (string, string, string) {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	argsForCall := fake.productArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeManager) ProductReturns(result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	fake.productReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	if fake.productReturnsOnCall == nil {
		fake.productReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.productReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Products(arg1 string, arg2 string) ([]*models.Product, error) {
	fake.productsMutex.Lock()
	ret, specificReturn := fake.productsReturnsOnCall[len(fake.productsArgsForCall)]
	fake.productsArgsForCall = append(fake.productsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ProductsStub
	fakeReturns := fake.productsReturns
	fake.recordInvocation("Products", []interface{}{arg1, arg2})
	fake.productsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ProductsCallCount() int {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	return len(fake.productsArgsForCall)
}

func (fake *FakeManager) ProductsCalls(stub func(string, string) ([]*models.Product, error)) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = stub
}

func (fake *FakeManager) ProductsArgsForCall(i int) (string, string) {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	argsForCall := fake.productsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) ProductsReturns(result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	fake.productsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	if fake.productsReturnsOnCall == nil {
		fake.productsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ProductsForCategory(arg1 string, arg2 string, arg3 models.Category) ([]*models.Product, error) {
	fake.productsForCategoryMutex.Lock()
	ret, specificReturn := fake.productsForCategoryReturnsOnCall[len(fake.productsForCategoryArgsForCall)]
	fake.productsForCategoryArgsForCall = append(fake.productsForCategoryArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 models.Category
	}{arg1, arg2, arg3})
	stub := fake.ProductsForCategoryStub
	fakeReturns := fake.productsForCategoryReturns
	fake.recordInvocation("ProductsForCategory", []interface{}{arg1, arg2, arg3})
	fake.productsForCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ProductsForCategoryCallCount() int {
	fake.productsForCategoryMutex.RLock()
	defer fake.productsForCategoryMutex.RUnlock()
	return len(fake.productsForCategoryArgsForCall)
}

func (fake *FakeManager) ProductsForCategoryCalls(stub func(string, string, models.Category) ([]*models.Product, error)) {
	fake.productsForCategoryMutex.Lock()
	defer fake.productsForCategoryMutex.Unlock()
	fake.ProductsForCategoryStub = stub
}

func (fake *FakeManager) ProductsForCategoryArgsForCall(i int) (string, string, models.Category) {
	fake.productsForCategoryMutex.RLock()
	defer fake.productsForCategoryMutex.RUnlock()
	argsForCall := fake.productsForCategoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeManager) ProductsForCategoryReturns(result1 []*models.Product, result2 error) {
	fake.productsForCategoryMutex.Lock()
	defer fake.productsForCategoryMutex.Unlock()
	fake.ProductsForCategoryStub = nil
	fake.productsForCategoryReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ProductsForCategoryReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForCategoryMutex.Lock()
	defer fake.productsForCategoryMutex.Unlock()
	fake.ProductsForCategoryStub = nil
	if fake.productsForCategoryReturnsOnCall == nil {
		fake.productsForCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForCategoryReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Terpenes(arg1 string, arg2 string) ([]*models.Terpene, error) {
	fake.terpenesMutex.Lock()
	ret, specificReturn := fake.terpenesReturnsOnCall[len(fake.terpenesArgsForCall)]
	fake.terpenesArgsForCall = append(fake.terpenesArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.TerpenesStub
	fakeReturns := fake.terpenesReturns
	fake.recordInvocation("Terpenes", []interface{}{arg1, arg2})
	fake.terpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) TerpenesCallCount() int {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	return len(fake.terpenesArgsForCall)
}

func (fake *FakeManager) TerpenesCalls(stub func(string, string) ([]*models.Terpene, error)) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = stub
}

func (fake *FakeManager) TerpenesArgsForCall(i int) (string, string) {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	argsForCall := fake.terpenesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) TerpenesReturns(result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	fake.terpenesReturns = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) TerpenesReturnsOnCall(i int, result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	if fake.terpenesReturnsOnCall == nil {
		fake.terpenesReturnsOnCall = make(map[int]struct {
			result1 []*models.Terpene
			result2 error
		})
	}
	fake.terpenesReturnsOnCall[i] = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	fake.menuMutex.RLock()
	defer fake.menuMutex.RUnlock()
	fake.menusMutex.RLock()
	defer fake.menusMutex.RUnlock()
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	fake.productsForCategoryMutex.RLock()
	defer fake.productsForCategoryMutex.RUnlock()
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ workflow.Manager = new(FakeManager)
