// Code generated by counterfeiter. DO NOT EDIT.
package workflowfakes

import (
	"context"
	"sync"

	"github.com/Linkinlog/LeafListr/internal/models"
	"github.com/Linkinlog/LeafListr/internal/transformation"
	"github.com/Linkinlog/LeafListr/internal/workflow"
)

type FakeWorkflow struct {
	CannabinoidsStub        func(workflow.WorkflowParams) ([]*models.Cannabinoid, error)
	cannabinoidsMutex       sync.RWMutex
	cannabinoidsArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	cannabinoidsReturns struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	cannabinoidsReturnsOnCall map[int]struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	CategoriesStub        func(workflow.WorkflowParams) ([]string, error)
	categoriesMutex       sync.RWMutex
	categoriesArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	categoriesReturns struct {
		result1 []string
		result2 error
	}
	categoriesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FilterStub        func(workflow.WorkflowParams, *transformation.FilterParams, []*models.Product) ([]*models.Product, error)
	filterMutex       sync.RWMutex
	filterArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 *transformation.FilterParams
		arg3 []*models.Product
	}
	filterReturns struct {
		result1 []*models.Product
		result2 error
	}
	filterReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	LocationStub        func(workflow.WorkflowParams) (*models.Location, error)
	locationMutex       sync.RWMutex
	locationArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	locationReturns struct {
		result1 *models.Location
		result2 error
	}
	locationReturnsOnCall map[int]struct {
		result1 *models.Location
		result2 error
	}
	LocationsStub        func(workflow.WorkflowParams) ([]*models.Location, error)
	locationsMutex       sync.RWMutex
	locationsArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	locationsReturns struct {
		result1 []*models.Location
		result2 error
	}
	locationsReturnsOnCall map[int]struct {
		result1 []*models.Location
		result2 error
	}
	LogErrorStub        func(error, context.Context)
	logErrorMutex       sync.RWMutex
	logErrorArgsForCall []struct {
		arg1 error
		arg2 context.Context
	}
	OffersStub        func(workflow.WorkflowParams) ([]*models.Offer, error)
	offersMutex       sync.RWMutex
	offersArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	offersReturns struct {
		result1 []*models.Offer
		result2 error
	}
	offersReturnsOnCall map[int]struct {
		result1 []*models.Offer
		result2 error
	}
	ProductStub        func(workflow.WorkflowParams, string) (*models.Product, error)
	productMutex       sync.RWMutex
	productArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}
	productReturns struct {
		result1 *models.Product
		result2 error
	}
	productReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	ProductsStub        func(workflow.WorkflowParams) ([]*models.Product, error)
	productsMutex       sync.RWMutex
	productsArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	productsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsExcludingBrandsStub        func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)
	productsExcludingBrandsMutex       sync.RWMutex
	productsExcludingBrandsArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}
	productsExcludingBrandsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsExcludingBrandsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsExcludingTermsStub        func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)
	productsExcludingTermsMutex       sync.RWMutex
	productsExcludingTermsArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}
	productsExcludingTermsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsExcludingTermsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForBrandsStub        func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)
	productsForBrandsMutex       sync.RWMutex
	productsForBrandsArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}
	productsForBrandsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForBrandsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForPriceRangeStub        func(workflow.WorkflowParams, []*models.Product, float64, float64) ([]*models.Product, error)
	productsForPriceRangeMutex       sync.RWMutex
	productsForPriceRangeArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 float64
		arg4 float64
	}
	productsForPriceRangeReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForPriceRangeReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForSubCategoryStub        func(workflow.WorkflowParams, []*models.Product, string) ([]*models.Product, error)
	productsForSubCategoryMutex       sync.RWMutex
	productsForSubCategoryArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 string
	}
	productsForSubCategoryReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForSubCategoryReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForVariantsStub        func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)
	productsForVariantsMutex       sync.RWMutex
	productsForVariantsArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}
	productsForVariantsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForVariantsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsInCategoryStub        func(workflow.WorkflowParams, string) ([]*models.Product, error)
	productsInCategoryMutex       sync.RWMutex
	productsInCategoryArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}
	productsInCategoryReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsInCategoryReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsIncludingTermsStub        func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)
	productsIncludingTermsMutex       sync.RWMutex
	productsIncludingTermsArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}
	productsIncludingTermsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsIncludingTermsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	SortStub        func(workflow.WorkflowParams, *transformation.SortParams, []*models.Product) error
	sortMutex       sync.RWMutex
	sortArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 *transformation.SortParams
		arg3 []*models.Product
	}
	sortReturns struct {
		result1 error
	}
	sortReturnsOnCall map[int]struct {
		result1 error
	}
	SortProductsByPriceAscStub        func(workflow.WorkflowParams, []*models.Product)
	sortProductsByPriceAscMutex       sync.RWMutex
	sortProductsByPriceAscArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}
	SortProductsByPriceDescStub        func(workflow.WorkflowParams, []*models.Product)
	sortProductsByPriceDescMutex       sync.RWMutex
	sortProductsByPriceDescArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}
	SortProductsByTHCAscStub        func(workflow.WorkflowParams, []*models.Product)
	sortProductsByTHCAscMutex       sync.RWMutex
	sortProductsByTHCAscArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}
	SortProductsByTHCDescStub        func(workflow.WorkflowParams, []*models.Product)
	sortProductsByTHCDescMutex       sync.RWMutex
	sortProductsByTHCDescArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}
	SortProductsByTop3TerpsStub        func(workflow.WorkflowParams, []*models.Product, [3]string)
	sortProductsByTop3TerpsMutex       sync.RWMutex
	sortProductsByTop3TerpsArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 [3]string
	}
	TerpenesStub        func(workflow.WorkflowParams) ([]*models.Terpene, error)
	terpenesMutex       sync.RWMutex
	terpenesArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	terpenesReturns struct {
		result1 []*models.Terpene
		result2 error
	}
	terpenesReturnsOnCall map[int]struct {
		result1 []*models.Terpene
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorkflow) Cannabinoids(arg1 workflow.WorkflowParams) ([]*models.Cannabinoid, error) {
	fake.cannabinoidsMutex.Lock()
	ret, specificReturn := fake.cannabinoidsReturnsOnCall[len(fake.cannabinoidsArgsForCall)]
	fake.cannabinoidsArgsForCall = append(fake.cannabinoidsArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.CannabinoidsStub
	fakeReturns := fake.cannabinoidsReturns
	fake.recordInvocation("Cannabinoids", []interface{}{arg1})
	fake.cannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) CannabinoidsCallCount() int {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	return len(fake.cannabinoidsArgsForCall)
}

func (fake *FakeWorkflow) CannabinoidsCalls(stub func(workflow.WorkflowParams) ([]*models.Cannabinoid, error)) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = stub
}

func (fake *FakeWorkflow) CannabinoidsArgsForCall(i int) workflow.WorkflowParams {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	argsForCall := fake.cannabinoidsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) CannabinoidsReturns(result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	fake.cannabinoidsReturns = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) CannabinoidsReturnsOnCall(i int, result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	if fake.cannabinoidsReturnsOnCall == nil {
		fake.cannabinoidsReturnsOnCall = make(map[int]struct {
			result1 []*models.Cannabinoid
			result2 error
		})
	}
	fake.cannabinoidsReturnsOnCall[i] = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Categories(arg1 workflow.WorkflowParams) ([]string, error) {
	fake.categoriesMutex.Lock()
	ret, specificReturn := fake.categoriesReturnsOnCall[len(fake.categoriesArgsForCall)]
	fake.categoriesArgsForCall = append(fake.categoriesArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.CategoriesStub
	fakeReturns := fake.categoriesReturns
	fake.recordInvocation("Categories", []interface{}{arg1})
	fake.categoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) CategoriesCallCount() int {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	return len(fake.categoriesArgsForCall)
}

func (fake *FakeWorkflow) CategoriesCalls(stub func(workflow.WorkflowParams) ([]string, error)) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = stub
}

func (fake *FakeWorkflow) CategoriesArgsForCall(i int) workflow.WorkflowParams {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	argsForCall := fake.categoriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) CategoriesReturns(result1 []string, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	fake.categoriesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) CategoriesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	if fake.categoriesReturnsOnCall == nil {
		fake.categoriesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.categoriesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Filter(arg1 workflow.WorkflowParams, arg2 *transformation.FilterParams, arg3 []*models.Product) ([]*models.Product, error) {
	var arg3Copy []*models.Product
	if arg3 != nil {
		arg3Copy = make([]*models.Product, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.filterMutex.Lock()
	ret, specificReturn := fake.filterReturnsOnCall[len(fake.filterArgsForCall)]
	fake.filterArgsForCall = append(fake.filterArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 *transformation.FilterParams
		arg3 []*models.Product
	}{arg1, arg2, arg3Copy})
	stub := fake.FilterStub
	fakeReturns := fake.filterReturns
	fake.recordInvocation("Filter", []interface{}{arg1, arg2, arg3Copy})
	fake.filterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) FilterCallCount() int {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	return len(fake.filterArgsForCall)
}

func (fake *FakeWorkflow) FilterCalls(stub func(workflow.WorkflowParams, *transformation.FilterParams, []*models.Product) ([]*models.Product, error)) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = stub
}

func (fake *FakeWorkflow) FilterArgsForCall(i int) (workflow.WorkflowParams, *transformation.FilterParams, []*models.Product) {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	argsForCall := fake.filterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) FilterReturns(result1 []*models.Product, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	fake.filterReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) FilterReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	if fake.filterReturnsOnCall == nil {
		fake.filterReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.filterReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Location(arg1 workflow.WorkflowParams) (*models.Location, error) {
	fake.locationMutex.Lock()
	ret, specificReturn := fake.locationReturnsOnCall[len(fake.locationArgsForCall)]
	fake.locationArgsForCall = append(fake.locationArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.LocationStub
	fakeReturns := fake.locationReturns
	fake.recordInvocation("Location", []interface{}{arg1})
	fake.locationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) LocationCallCount() int {
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	return len(fake.locationArgsForCall)
}

func (fake *FakeWorkflow) LocationCalls(stub func(workflow.WorkflowParams) (*models.Location, error)) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = stub
}

func (fake *FakeWorkflow) LocationArgsForCall(i int) workflow.WorkflowParams {
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	argsForCall := fake.locationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) LocationReturns(result1 *models.Location, result2 error) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = nil
	fake.locationReturns = struct {
		result1 *models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LocationReturnsOnCall(i int, result1 *models.Location, result2 error) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = nil
	if fake.locationReturnsOnCall == nil {
		fake.locationReturnsOnCall = make(map[int]struct {
			result1 *models.Location
			result2 error
		})
	}
	fake.locationReturnsOnCall[i] = struct {
		result1 *models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Locations(arg1 workflow.WorkflowParams) ([]*models.Location, error) {
	fake.locationsMutex.Lock()
	ret, specificReturn := fake.locationsReturnsOnCall[len(fake.locationsArgsForCall)]
	fake.locationsArgsForCall = append(fake.locationsArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.LocationsStub
	fakeReturns := fake.locationsReturns
	fake.recordInvocation("Locations", []interface{}{arg1})
	fake.locationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) LocationsCallCount() int {
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	return len(fake.locationsArgsForCall)
}

func (fake *FakeWorkflow) LocationsCalls(stub func(workflow.WorkflowParams) ([]*models.Location, error)) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = stub
}

func (fake *FakeWorkflow) LocationsArgsForCall(i int) workflow.WorkflowParams {
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	argsForCall := fake.locationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) LocationsReturns(result1 []*models.Location, result2 error) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = nil
	fake.locationsReturns = struct {
		result1 []*models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LocationsReturnsOnCall(i int, result1 []*models.Location, result2 error) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = nil
	if fake.locationsReturnsOnCall == nil {
		fake.locationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Location
			result2 error
		})
	}
	fake.locationsReturnsOnCall[i] = struct {
		result1 []*models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LogError(arg1 error, arg2 context.Context) {
	fake.logErrorMutex.Lock()
	fake.logErrorArgsForCall = append(fake.logErrorArgsForCall, struct {
		arg1 error
		arg2 context.Context
	}{arg1, arg2})
	stub := fake.LogErrorStub
	fake.recordInvocation("LogError", []interface{}{arg1, arg2})
	fake.logErrorMutex.Unlock()
	if stub != nil {
		fake.LogErrorStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) LogErrorCallCount() int {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	return len(fake.logErrorArgsForCall)
}

func (fake *FakeWorkflow) LogErrorCalls(stub func(error, context.Context)) {
	fake.logErrorMutex.Lock()
	defer fake.logErrorMutex.Unlock()
	fake.LogErrorStub = stub
}

func (fake *FakeWorkflow) LogErrorArgsForCall(i int) (error, context.Context) {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	argsForCall := fake.logErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) Offers(arg1 workflow.WorkflowParams) ([]*models.Offer, error) {
	fake.offersMutex.Lock()
	ret, specificReturn := fake.offersReturnsOnCall[len(fake.offersArgsForCall)]
	fake.offersArgsForCall = append(fake.offersArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.OffersStub
	fakeReturns := fake.offersReturns
	fake.recordInvocation("Offers", []interface{}{arg1})
	fake.offersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) OffersCallCount() int {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	return len(fake.offersArgsForCall)
}

func (fake *FakeWorkflow) OffersCalls(stub func(workflow.WorkflowParams) ([]*models.Offer, error)) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = stub
}

func (fake *FakeWorkflow) OffersArgsForCall(i int) workflow.WorkflowParams {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	argsForCall := fake.offersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) OffersReturns(result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	fake.offersReturns = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) OffersReturnsOnCall(i int, result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	if fake.offersReturnsOnCall == nil {
		fake.offersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
			result2 error
		})
	}
	fake.offersReturnsOnCall[i] = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Product(arg1 workflow.WorkflowParams, arg2 string) (*models.Product, error) {
	fake.productMutex.Lock()
	ret, specificReturn := fake.productReturnsOnCall[len(fake.productArgsForCall)]
	fake.productArgsForCall = append(fake.productArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}{arg1, arg2})
	stub := fake.ProductStub
	fakeReturns := fake.productReturns
	fake.recordInvocation("Product", []interface{}{arg1, arg2})
	fake.productMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductCallCount() int {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	return len(fake.productArgsForCall)
}

func (fake *FakeWorkflow) ProductCalls(stub func(workflow.WorkflowParams, string) (*models.Product, error)) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = stub
}

func (fake *FakeWorkflow) ProductArgsForCall(i int) (workflow.WorkflowParams, string) {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	argsForCall := fake.productArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) ProductReturns(result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	fake.productReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	if fake.productReturnsOnCall == nil {
		fake.productReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.productReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Products(arg1 workflow.WorkflowParams) ([]*models.Product, error) {
	fake.productsMutex.Lock()
	ret, specificReturn := fake.productsReturnsOnCall[len(fake.productsArgsForCall)]
	fake.productsArgsForCall = append(fake.productsArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.ProductsStub
	fakeReturns := fake.productsReturns
	fake.recordInvocation("Products", []interface{}{arg1})
	fake.productsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsCallCount() int {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	return len(fake.productsArgsForCall)
}

func (fake *FakeWorkflow) ProductsCalls(stub func(workflow.WorkflowParams) ([]*models.Product, error)) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = stub
}

func (fake *FakeWorkflow) ProductsArgsForCall(i int) workflow.WorkflowParams {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	argsForCall := fake.productsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) ProductsReturns(result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	fake.productsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	if fake.productsReturnsOnCall == nil {
		fake.productsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsExcludingBrands(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 []string) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.productsExcludingBrandsMutex.Lock()
	ret, specificReturn := fake.productsExcludingBrandsReturnsOnCall[len(fake.productsExcludingBrandsArgsForCall)]
	fake.productsExcludingBrandsArgsForCall = append(fake.productsExcludingBrandsArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	stub := fake.ProductsExcludingBrandsStub
	fakeReturns := fake.productsExcludingBrandsReturns
	fake.recordInvocation("ProductsExcludingBrands", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.productsExcludingBrandsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsExcludingBrandsCallCount() int {
	fake.productsExcludingBrandsMutex.RLock()
	defer fake.productsExcludingBrandsMutex.RUnlock()
	return len(fake.productsExcludingBrandsArgsForCall)
}

func (fake *FakeWorkflow) ProductsExcludingBrandsCalls(stub func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsExcludingBrandsMutex.Lock()
	defer fake.productsExcludingBrandsMutex.Unlock()
	fake.ProductsExcludingBrandsStub = stub
}

func (fake *FakeWorkflow) ProductsExcludingBrandsArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, []string) {
	fake.productsExcludingBrandsMutex.RLock()
	defer fake.productsExcludingBrandsMutex.RUnlock()
	argsForCall := fake.productsExcludingBrandsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsExcludingBrandsReturns(result1 []*models.Product, result2 error) {
	fake.productsExcludingBrandsMutex.Lock()
	defer fake.productsExcludingBrandsMutex.Unlock()
	fake.ProductsExcludingBrandsStub = nil
	fake.productsExcludingBrandsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsExcludingBrandsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsExcludingBrandsMutex.Lock()
	defer fake.productsExcludingBrandsMutex.Unlock()
	fake.ProductsExcludingBrandsStub = nil
	if fake.productsExcludingBrandsReturnsOnCall == nil {
		fake.productsExcludingBrandsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsExcludingBrandsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsExcludingTerms(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 []string) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.productsExcludingTermsMutex.Lock()
	ret, specificReturn := fake.productsExcludingTermsReturnsOnCall[len(fake.productsExcludingTermsArgsForCall)]
	fake.productsExcludingTermsArgsForCall = append(fake.productsExcludingTermsArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	stub := fake.ProductsExcludingTermsStub
	fakeReturns := fake.productsExcludingTermsReturns
	fake.recordInvocation("ProductsExcludingTerms", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.productsExcludingTermsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsExcludingTermsCallCount() int {
	fake.productsExcludingTermsMutex.RLock()
	defer fake.productsExcludingTermsMutex.RUnlock()
	return len(fake.productsExcludingTermsArgsForCall)
}

func (fake *FakeWorkflow) ProductsExcludingTermsCalls(stub func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsExcludingTermsMutex.Lock()
	defer fake.productsExcludingTermsMutex.Unlock()
	fake.ProductsExcludingTermsStub = stub
}

func (fake *FakeWorkflow) ProductsExcludingTermsArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, []string) {
	fake.productsExcludingTermsMutex.RLock()
	defer fake.productsExcludingTermsMutex.RUnlock()
	argsForCall := fake.productsExcludingTermsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsExcludingTermsReturns(result1 []*models.Product, result2 error) {
	fake.productsExcludingTermsMutex.Lock()
	defer fake.productsExcludingTermsMutex.Unlock()
	fake.ProductsExcludingTermsStub = nil
	fake.productsExcludingTermsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsExcludingTermsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsExcludingTermsMutex.Lock()
	defer fake.productsExcludingTermsMutex.Unlock()
	fake.ProductsExcludingTermsStub = nil
	if fake.productsExcludingTermsReturnsOnCall == nil {
		fake.productsExcludingTermsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsExcludingTermsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForBrands(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 []string) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.productsForBrandsMutex.Lock()
	ret, specificReturn := fake.productsForBrandsReturnsOnCall[len(fake.productsForBrandsArgsForCall)]
	fake.productsForBrandsArgsForCall = append(fake.productsForBrandsArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	stub := fake.ProductsForBrandsStub
	fakeReturns := fake.productsForBrandsReturns
	fake.recordInvocation("ProductsForBrands", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.productsForBrandsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForBrandsCallCount() int {
	fake.productsForBrandsMutex.RLock()
	defer fake.productsForBrandsMutex.RUnlock()
	return len(fake.productsForBrandsArgsForCall)
}

func (fake *FakeWorkflow) ProductsForBrandsCalls(stub func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsForBrandsMutex.Lock()
	defer fake.productsForBrandsMutex.Unlock()
	fake.ProductsForBrandsStub = stub
}

func (fake *FakeWorkflow) ProductsForBrandsArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, []string) {
	fake.productsForBrandsMutex.RLock()
	defer fake.productsForBrandsMutex.RUnlock()
	argsForCall := fake.productsForBrandsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsForBrandsReturns(result1 []*models.Product, result2 error) {
	fake.productsForBrandsMutex.Lock()
	defer fake.productsForBrandsMutex.Unlock()
	fake.ProductsForBrandsStub = nil
	fake.productsForBrandsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForBrandsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForBrandsMutex.Lock()
	defer fake.productsForBrandsMutex.Unlock()
	fake.ProductsForBrandsStub = nil
	if fake.productsForBrandsReturnsOnCall == nil {
		fake.productsForBrandsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForBrandsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForPriceRange(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 float64, arg4 float64) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.productsForPriceRangeMutex.Lock()
	ret, specificReturn := fake.productsForPriceRangeReturnsOnCall[len(fake.productsForPriceRangeArgsForCall)]
	fake.productsForPriceRangeArgsForCall = append(fake.productsForPriceRangeArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 float64
		arg4 float64
	}{arg1, arg2Copy, arg3, arg4})
	stub := fake.ProductsForPriceRangeStub
	fakeReturns := fake.productsForPriceRangeReturns
	fake.recordInvocation("ProductsForPriceRange", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.productsForPriceRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForPriceRangeCallCount() int {
	fake.productsForPriceRangeMutex.RLock()
	defer fake.productsForPriceRangeMutex.RUnlock()
	return len(fake.productsForPriceRangeArgsForCall)
}

func (fake *FakeWorkflow) ProductsForPriceRangeCalls(stub func(workflow.WorkflowParams, []*models.Product, float64, float64) ([]*models.Product, error)) {
	fake.productsForPriceRangeMutex.Lock()
	defer fake.productsForPriceRangeMutex.Unlock()
	fake.ProductsForPriceRangeStub = stub
}

func (fake *FakeWorkflow) ProductsForPriceRangeArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, float64, float64) {
	fake.productsForPriceRangeMutex.RLock()
	defer fake.productsForPriceRangeMutex.RUnlock()
	argsForCall := fake.productsForPriceRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) ProductsForPriceRangeReturns(result1 []*models.Product, result2 error) {
	fake.productsForPriceRangeMutex.Lock()
	defer fake.productsForPriceRangeMutex.Unlock()
	fake.ProductsForPriceRangeStub = nil
	fake.productsForPriceRangeReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForPriceRangeReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForPriceRangeMutex.Lock()
	defer fake.productsForPriceRangeMutex.Unlock()
	fake.ProductsForPriceRangeStub = nil
	if fake.productsForPriceRangeReturnsOnCall == nil {
		fake.productsForPriceRangeReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForPriceRangeReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForSubCategory(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 string) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.productsForSubCategoryMutex.Lock()
	ret, specificReturn := fake.productsForSubCategoryReturnsOnCall[len(fake.productsForSubCategoryArgsForCall)]
	fake.productsForSubCategoryArgsForCall = append(fake.productsForSubCategoryArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 string
	}{arg1, arg2Copy, arg3})
	stub := fake.ProductsForSubCategoryStub
	fakeReturns := fake.productsForSubCategoryReturns
	fake.recordInvocation("ProductsForSubCategory", []interface{}{arg1, arg2Copy, arg3})
	fake.productsForSubCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForSubCategoryCallCount() int {
	fake.productsForSubCategoryMutex.RLock()
	defer fake.productsForSubCategoryMutex.RUnlock()
	return len(fake.productsForSubCategoryArgsForCall)
}

func (fake *FakeWorkflow) ProductsForSubCategoryCalls(stub func(workflow.WorkflowParams, []*models.Product, string) ([]*models.Product, error)) {
	fake.productsForSubCategoryMutex.Lock()
	defer fake.productsForSubCategoryMutex.Unlock()
	fake.ProductsForSubCategoryStub = stub
}

func (fake *FakeWorkflow) ProductsForSubCategoryArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, string) {
	fake.productsForSubCategoryMutex.RLock()
	defer fake.productsForSubCategoryMutex.RUnlock()
	argsForCall := fake.productsForSubCategoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsForSubCategoryReturns(result1 []*models.Product, result2 error) {
	fake.productsForSubCategoryMutex.Lock()
	defer fake.productsForSubCategoryMutex.Unlock()
	fake.ProductsForSubCategoryStub = nil
	fake.productsForSubCategoryReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForSubCategoryReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForSubCategoryMutex.Lock()
	defer fake.productsForSubCategoryMutex.Unlock()
	fake.ProductsForSubCategoryStub = nil
	if fake.productsForSubCategoryReturnsOnCall == nil {
		fake.productsForSubCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForSubCategoryReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForVariants(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 []string) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.productsForVariantsMutex.Lock()
	ret, specificReturn := fake.productsForVariantsReturnsOnCall[len(fake.productsForVariantsArgsForCall)]
	fake.productsForVariantsArgsForCall = append(fake.productsForVariantsArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	stub := fake.ProductsForVariantsStub
	fakeReturns := fake.productsForVariantsReturns
	fake.recordInvocation("ProductsForVariants", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.productsForVariantsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForVariantsCallCount() int {
	fake.productsForVariantsMutex.RLock()
	defer fake.productsForVariantsMutex.RUnlock()
	return len(fake.productsForVariantsArgsForCall)
}

func (fake *FakeWorkflow) ProductsForVariantsCalls(stub func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsForVariantsMutex.Lock()
	defer fake.productsForVariantsMutex.Unlock()
	fake.ProductsForVariantsStub = stub
}

func (fake *FakeWorkflow) ProductsForVariantsArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, []string) {
	fake.productsForVariantsMutex.RLock()
	defer fake.productsForVariantsMutex.RUnlock()
	argsForCall := fake.productsForVariantsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsForVariantsReturns(result1 []*models.Product, result2 error) {
	fake.productsForVariantsMutex.Lock()
	defer fake.productsForVariantsMutex.Unlock()
	fake.ProductsForVariantsStub = nil
	fake.productsForVariantsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForVariantsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForVariantsMutex.Lock()
	defer fake.productsForVariantsMutex.Unlock()
	fake.ProductsForVariantsStub = nil
	if fake.productsForVariantsReturnsOnCall == nil {
		fake.productsForVariantsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForVariantsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsInCategory(arg1 workflow.WorkflowParams, arg2 string) ([]*models.Product, error) {
	fake.productsInCategoryMutex.Lock()
	ret, specificReturn := fake.productsInCategoryReturnsOnCall[len(fake.productsInCategoryArgsForCall)]
	fake.productsInCategoryArgsForCall = append(fake.productsInCategoryArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}{arg1, arg2})
	stub := fake.ProductsInCategoryStub
	fakeReturns := fake.productsInCategoryReturns
	fake.recordInvocation("ProductsInCategory", []interface{}{arg1, arg2})
	fake.productsInCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsInCategoryCallCount() int {
	fake.productsInCategoryMutex.RLock()
	defer fake.productsInCategoryMutex.RUnlock()
	return len(fake.productsInCategoryArgsForCall)
}

func (fake *FakeWorkflow) ProductsInCategoryCalls(stub func(workflow.WorkflowParams, string) ([]*models.Product, error)) {
	fake.productsInCategoryMutex.Lock()
	defer fake.productsInCategoryMutex.Unlock()
	fake.ProductsInCategoryStub = stub
}

func (fake *FakeWorkflow) ProductsInCategoryArgsForCall(i int) (workflow.WorkflowParams, string) {
	fake.productsInCategoryMutex.RLock()
	defer fake.productsInCategoryMutex.RUnlock()
	argsForCall := fake.productsInCategoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) ProductsInCategoryReturns(result1 []*models.Product, result2 error) {
	fake.productsInCategoryMutex.Lock()
	defer fake.productsInCategoryMutex.Unlock()
	fake.ProductsInCategoryStub = nil
	fake.productsInCategoryReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsInCategoryReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsInCategoryMutex.Lock()
	defer fake.productsInCategoryMutex.Unlock()
	fake.ProductsInCategoryStub = nil
	if fake.productsInCategoryReturnsOnCall == nil {
		fake.productsInCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsInCategoryReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsIncludingTerms(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 []string) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.productsIncludingTermsMutex.Lock()
	ret, specificReturn := fake.productsIncludingTermsReturnsOnCall[len(fake.productsIncludingTermsArgsForCall)]
	fake.productsIncludingTermsArgsForCall = append(fake.productsIncludingTermsArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	stub := fake.ProductsIncludingTermsStub
	fakeReturns := fake.productsIncludingTermsReturns
	fake.recordInvocation("ProductsIncludingTerms", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.productsIncludingTermsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsIncludingTermsCallCount() int {
	fake.productsIncludingTermsMutex.RLock()
	defer fake.productsIncludingTermsMutex.RUnlock()
	return len(fake.productsIncludingTermsArgsForCall)
}

func (fake *FakeWorkflow) ProductsIncludingTermsCalls(stub func(workflow.WorkflowParams, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsIncludingTermsMutex.Lock()
	defer fake.productsIncludingTermsMutex.Unlock()
	fake.ProductsIncludingTermsStub = stub
}

func (fake *FakeWorkflow) ProductsIncludingTermsArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, []string) {
	fake.productsIncludingTermsMutex.RLock()
	defer fake.productsIncludingTermsMutex.RUnlock()
	argsForCall := fake.productsIncludingTermsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsIncludingTermsReturns(result1 []*models.Product, result2 error) {
	fake.productsIncludingTermsMutex.Lock()
	defer fake.productsIncludingTermsMutex.Unlock()
	fake.ProductsIncludingTermsStub = nil
	fake.productsIncludingTermsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsIncludingTermsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsIncludingTermsMutex.Lock()
	defer fake.productsIncludingTermsMutex.Unlock()
	fake.ProductsIncludingTermsStub = nil
	if fake.productsIncludingTermsReturnsOnCall == nil {
		fake.productsIncludingTermsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsIncludingTermsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Sort(arg1 workflow.WorkflowParams, arg2 *transformation.SortParams, arg3 []*models.Product) error {
	var arg3Copy []*models.Product
	if arg3 != nil {
		arg3Copy = make([]*models.Product, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.sortMutex.Lock()
	ret, specificReturn := fake.sortReturnsOnCall[len(fake.sortArgsForCall)]
	fake.sortArgsForCall = append(fake.sortArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 *transformation.SortParams
		arg3 []*models.Product
	}{arg1, arg2, arg3Copy})
	stub := fake.SortStub
	fakeReturns := fake.sortReturns
	fake.recordInvocation("Sort", []interface{}{arg1, arg2, arg3Copy})
	fake.sortMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkflow) SortCallCount() int {
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	return len(fake.sortArgsForCall)
}

func (fake *FakeWorkflow) SortCalls(stub func(workflow.WorkflowParams, *transformation.SortParams, []*models.Product) error) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = stub
}

func (fake *FakeWorkflow) SortArgsForCall(i int) (workflow.WorkflowParams, *transformation.SortParams, []*models.Product) {
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	argsForCall := fake.sortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) SortReturns(result1 error) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = nil
	fake.sortReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkflow) SortReturnsOnCall(i int, result1 error) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = nil
	if fake.sortReturnsOnCall == nil {
		fake.sortReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sortReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkflow) SortProductsByPriceAsc(arg1 workflow.WorkflowParams, arg2 []*models.Product) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sortProductsByPriceAscMutex.Lock()
	fake.sortProductsByPriceAscArgsForCall = append(fake.sortProductsByPriceAscArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}{arg1, arg2Copy})
	stub := fake.SortProductsByPriceAscStub
	fake.recordInvocation("SortProductsByPriceAsc", []interface{}{arg1, arg2Copy})
	fake.sortProductsByPriceAscMutex.Unlock()
	if stub != nil {
		fake.SortProductsByPriceAscStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) SortProductsByPriceAscCallCount() int {
	fake.sortProductsByPriceAscMutex.RLock()
	defer fake.sortProductsByPriceAscMutex.RUnlock()
	return len(fake.sortProductsByPriceAscArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByPriceAscCalls(stub func(workflow.WorkflowParams, []*models.Product)) {
	fake.sortProductsByPriceAscMutex.Lock()
	defer fake.sortProductsByPriceAscMutex.Unlock()
	fake.SortProductsByPriceAscStub = stub
}

func (fake *FakeWorkflow) SortProductsByPriceAscArgsForCall(i int) (workflow.WorkflowParams, []*models.Product) {
	fake.sortProductsByPriceAscMutex.RLock()
	defer fake.sortProductsByPriceAscMutex.RUnlock()
	argsForCall := fake.sortProductsByPriceAscArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) SortProductsByPriceDesc(arg1 workflow.WorkflowParams, arg2 []*models.Product) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sortProductsByPriceDescMutex.Lock()
	fake.sortProductsByPriceDescArgsForCall = append(fake.sortProductsByPriceDescArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}{arg1, arg2Copy})
	stub := fake.SortProductsByPriceDescStub
	fake.recordInvocation("SortProductsByPriceDesc", []interface{}{arg1, arg2Copy})
	fake.sortProductsByPriceDescMutex.Unlock()
	if stub != nil {
		fake.SortProductsByPriceDescStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) SortProductsByPriceDescCallCount() int {
	fake.sortProductsByPriceDescMutex.RLock()
	defer fake.sortProductsByPriceDescMutex.RUnlock()
	return len(fake.sortProductsByPriceDescArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByPriceDescCalls(stub func(workflow.WorkflowParams, []*models.Product)) {
	fake.sortProductsByPriceDescMutex.Lock()
	defer fake.sortProductsByPriceDescMutex.Unlock()
	fake.SortProductsByPriceDescStub = stub
}

func (fake *FakeWorkflow) SortProductsByPriceDescArgsForCall(i int) (workflow.WorkflowParams, []*models.Product) {
	fake.sortProductsByPriceDescMutex.RLock()
	defer fake.sortProductsByPriceDescMutex.RUnlock()
	argsForCall := fake.sortProductsByPriceDescArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) SortProductsByTHCAsc(arg1 workflow.WorkflowParams, arg2 []*models.Product) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sortProductsByTHCAscMutex.Lock()
	fake.sortProductsByTHCAscArgsForCall = append(fake.sortProductsByTHCAscArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}{arg1, arg2Copy})
	stub := fake.SortProductsByTHCAscStub
	fake.recordInvocation("SortProductsByTHCAsc", []interface{}{arg1, arg2Copy})
	fake.sortProductsByTHCAscMutex.Unlock()
	if stub != nil {
		fake.SortProductsByTHCAscStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) SortProductsByTHCAscCallCount() int {
	fake.sortProductsByTHCAscMutex.RLock()
	defer fake.sortProductsByTHCAscMutex.RUnlock()
	return len(fake.sortProductsByTHCAscArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByTHCAscCalls(stub func(workflow.WorkflowParams, []*models.Product)) {
	fake.sortProductsByTHCAscMutex.Lock()
	defer fake.sortProductsByTHCAscMutex.Unlock()
	fake.SortProductsByTHCAscStub = stub
}

func (fake *FakeWorkflow) SortProductsByTHCAscArgsForCall(i int) (workflow.WorkflowParams, []*models.Product) {
	fake.sortProductsByTHCAscMutex.RLock()
	defer fake.sortProductsByTHCAscMutex.RUnlock()
	argsForCall := fake.sortProductsByTHCAscArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) SortProductsByTHCDesc(arg1 workflow.WorkflowParams, arg2 []*models.Product) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sortProductsByTHCDescMutex.Lock()
	fake.sortProductsByTHCDescArgsForCall = append(fake.sortProductsByTHCDescArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
	}{arg1, arg2Copy})
	stub := fake.SortProductsByTHCDescStub
	fake.recordInvocation("SortProductsByTHCDesc", []interface{}{arg1, arg2Copy})
	fake.sortProductsByTHCDescMutex.Unlock()
	if stub != nil {
		fake.SortProductsByTHCDescStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) SortProductsByTHCDescCallCount() int {
	fake.sortProductsByTHCDescMutex.RLock()
	defer fake.sortProductsByTHCDescMutex.RUnlock()
	return len(fake.sortProductsByTHCDescArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByTHCDescCalls(stub func(workflow.WorkflowParams, []*models.Product)) {
	fake.sortProductsByTHCDescMutex.Lock()
	defer fake.sortProductsByTHCDescMutex.Unlock()
	fake.SortProductsByTHCDescStub = stub
}

func (fake *FakeWorkflow) SortProductsByTHCDescArgsForCall(i int) (workflow.WorkflowParams, []*models.Product) {
	fake.sortProductsByTHCDescMutex.RLock()
	defer fake.sortProductsByTHCDescMutex.RUnlock()
	argsForCall := fake.sortProductsByTHCDescArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) SortProductsByTop3Terps(arg1 workflow.WorkflowParams, arg2 []*models.Product, arg3 [3]string) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sortProductsByTop3TerpsMutex.Lock()
	fake.sortProductsByTop3TerpsArgsForCall = append(fake.sortProductsByTop3TerpsArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 []*models.Product
		arg3 [3]string
	}{arg1, arg2Copy, arg3})
	stub := fake.SortProductsByTop3TerpsStub
	fake.recordInvocation("SortProductsByTop3Terps", []interface{}{arg1, arg2Copy, arg3})
	fake.sortProductsByTop3TerpsMutex.Unlock()
	if stub != nil {
		fake.SortProductsByTop3TerpsStub(arg1, arg2, arg3)
	}
}

func (fake *FakeWorkflow) SortProductsByTop3TerpsCallCount() int {
	fake.sortProductsByTop3TerpsMutex.RLock()
	defer fake.sortProductsByTop3TerpsMutex.RUnlock()
	return len(fake.sortProductsByTop3TerpsArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByTop3TerpsCalls(stub func(workflow.WorkflowParams, []*models.Product, [3]string)) {
	fake.sortProductsByTop3TerpsMutex.Lock()
	defer fake.sortProductsByTop3TerpsMutex.Unlock()
	fake.SortProductsByTop3TerpsStub = stub
}

func (fake *FakeWorkflow) SortProductsByTop3TerpsArgsForCall(i int) (workflow.WorkflowParams, []*models.Product, [3]string) {
	fake.sortProductsByTop3TerpsMutex.RLock()
	defer fake.sortProductsByTop3TerpsMutex.RUnlock()
	argsForCall := fake.sortProductsByTop3TerpsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) Terpenes(arg1 workflow.WorkflowParams) ([]*models.Terpene, error) {
	fake.terpenesMutex.Lock()
	ret, specificReturn := fake.terpenesReturnsOnCall[len(fake.terpenesArgsForCall)]
	fake.terpenesArgsForCall = append(fake.terpenesArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.TerpenesStub
	fakeReturns := fake.terpenesReturns
	fake.recordInvocation("Terpenes", []interface{}{arg1})
	fake.terpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) TerpenesCallCount() int {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	return len(fake.terpenesArgsForCall)
}

func (fake *FakeWorkflow) TerpenesCalls(stub func(workflow.WorkflowParams) ([]*models.Terpene, error)) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = stub
}

func (fake *FakeWorkflow) TerpenesArgsForCall(i int) workflow.WorkflowParams {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	argsForCall := fake.terpenesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) TerpenesReturns(result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	fake.terpenesReturns = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) TerpenesReturnsOnCall(i int, result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	if fake.terpenesReturnsOnCall == nil {
		fake.terpenesReturnsOnCall = make(map[int]struct {
			result1 []*models.Terpene
			result2 error
		})
	}
	fake.terpenesReturnsOnCall[i] = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	fake.productsExcludingBrandsMutex.RLock()
	defer fake.productsExcludingBrandsMutex.RUnlock()
	fake.productsExcludingTermsMutex.RLock()
	defer fake.productsExcludingTermsMutex.RUnlock()
	fake.productsForBrandsMutex.RLock()
	defer fake.productsForBrandsMutex.RUnlock()
	fake.productsForPriceRangeMutex.RLock()
	defer fake.productsForPriceRangeMutex.RUnlock()
	fake.productsForSubCategoryMutex.RLock()
	defer fake.productsForSubCategoryMutex.RUnlock()
	fake.productsForVariantsMutex.RLock()
	defer fake.productsForVariantsMutex.RUnlock()
	fake.productsInCategoryMutex.RLock()
	defer fake.productsInCategoryMutex.RUnlock()
	fake.productsIncludingTermsMutex.RLock()
	defer fake.productsIncludingTermsMutex.RUnlock()
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	fake.sortProductsByPriceAscMutex.RLock()
	defer fake.sortProductsByPriceAscMutex.RUnlock()
	fake.sortProductsByPriceDescMutex.RLock()
	defer fake.sortProductsByPriceDescMutex.RUnlock()
	fake.sortProductsByTHCAscMutex.RLock()
	defer fake.sortProductsByTHCAscMutex.RUnlock()
	fake.sortProductsByTHCDescMutex.RLock()
	defer fake.sortProductsByTHCDescMutex.RUnlock()
	fake.sortProductsByTop3TerpsMutex.RLock()
	defer fake.sortProductsByTop3TerpsMutex.RUnlock()
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorkflow) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ workflow.Workflow = new(FakeWorkflow)
