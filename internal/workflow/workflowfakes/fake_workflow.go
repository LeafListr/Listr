// Code generated by counterfeiter. DO NOT EDIT.
package workflowfakes

import (
	"context"
	"sync"

	"github.com/Linkinlog/LeafListr/internal/models"
	"github.com/Linkinlog/LeafListr/internal/transformation"
	"github.com/Linkinlog/LeafListr/internal/workflow"
)

type FakeWorkflow struct {
	CannabinoidsStub        func(workflow.WorkflowParams) ([]*models.Cannabinoid, error)
	cannabinoidsMutex       sync.RWMutex
	cannabinoidsArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	cannabinoidsReturns struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	cannabinoidsReturnsOnCall map[int]struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	CategoriesStub        func(workflow.WorkflowParams) ([]string, error)
	categoriesMutex       sync.RWMutex
	categoriesArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	categoriesReturns struct {
		result1 []string
		result2 error
	}
	categoriesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FilterStub        func(*transformation.FilterParams, []*models.Product) ([]*models.Product, error)
	filterMutex       sync.RWMutex
	filterArgsForCall []struct {
		arg1 *transformation.FilterParams
		arg2 []*models.Product
	}
	filterReturns struct {
		result1 []*models.Product
		result2 error
	}
	filterReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	LocationStub        func(workflow.WorkflowParams) (*models.Location, error)
	locationMutex       sync.RWMutex
	locationArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	locationReturns struct {
		result1 *models.Location
		result2 error
	}
	locationReturnsOnCall map[int]struct {
		result1 *models.Location
		result2 error
	}
	LocationsStub        func(workflow.WorkflowParams) ([]*models.Location, error)
	locationsMutex       sync.RWMutex
	locationsArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	locationsReturns struct {
		result1 []*models.Location
		result2 error
	}
	locationsReturnsOnCall map[int]struct {
		result1 []*models.Location
		result2 error
	}
	LogErrorStub        func(error, context.Context)
	logErrorMutex       sync.RWMutex
	logErrorArgsForCall []struct {
		arg1 error
		arg2 context.Context
	}
	OffersStub        func(workflow.WorkflowParams) ([]*models.Offer, error)
	offersMutex       sync.RWMutex
	offersArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	offersReturns struct {
		result1 []*models.Offer
		result2 error
	}
	offersReturnsOnCall map[int]struct {
		result1 []*models.Offer
		result2 error
	}
	ProductStub        func(workflow.WorkflowParams, string) (*models.Product, error)
	productMutex       sync.RWMutex
	productArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}
	productReturns struct {
		result1 *models.Product
		result2 error
	}
	productReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	ProductsStub        func(workflow.WorkflowParams) ([]*models.Product, error)
	productsMutex       sync.RWMutex
	productsArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	productsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsInCategoryStub        func(workflow.WorkflowParams, string) ([]*models.Product, error)
	productsInCategoryMutex       sync.RWMutex
	productsInCategoryArgsForCall []struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}
	productsInCategoryReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsInCategoryReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	SortStub        func(*transformation.SortParams, []*models.Product) error
	sortMutex       sync.RWMutex
	sortArgsForCall []struct {
		arg1 *transformation.SortParams
		arg2 []*models.Product
	}
	sortReturns struct {
		result1 error
	}
	sortReturnsOnCall map[int]struct {
		result1 error
	}
	TerpenesStub        func(workflow.WorkflowParams) ([]*models.Terpene, error)
	terpenesMutex       sync.RWMutex
	terpenesArgsForCall []struct {
		arg1 workflow.WorkflowParams
	}
	terpenesReturns struct {
		result1 []*models.Terpene
		result2 error
	}
	terpenesReturnsOnCall map[int]struct {
		result1 []*models.Terpene
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorkflow) Cannabinoids(arg1 workflow.WorkflowParams) ([]*models.Cannabinoid, error) {
	fake.cannabinoidsMutex.Lock()
	ret, specificReturn := fake.cannabinoidsReturnsOnCall[len(fake.cannabinoidsArgsForCall)]
	fake.cannabinoidsArgsForCall = append(fake.cannabinoidsArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.CannabinoidsStub
	fakeReturns := fake.cannabinoidsReturns
	fake.recordInvocation("Cannabinoids", []interface{}{arg1})
	fake.cannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) CannabinoidsCallCount() int {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	return len(fake.cannabinoidsArgsForCall)
}

func (fake *FakeWorkflow) CannabinoidsCalls(stub func(workflow.WorkflowParams) ([]*models.Cannabinoid, error)) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = stub
}

func (fake *FakeWorkflow) CannabinoidsArgsForCall(i int) workflow.WorkflowParams {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	argsForCall := fake.cannabinoidsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) CannabinoidsReturns(result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	fake.cannabinoidsReturns = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) CannabinoidsReturnsOnCall(i int, result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	if fake.cannabinoidsReturnsOnCall == nil {
		fake.cannabinoidsReturnsOnCall = make(map[int]struct {
			result1 []*models.Cannabinoid
			result2 error
		})
	}
	fake.cannabinoidsReturnsOnCall[i] = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Categories(arg1 workflow.WorkflowParams) ([]string, error) {
	fake.categoriesMutex.Lock()
	ret, specificReturn := fake.categoriesReturnsOnCall[len(fake.categoriesArgsForCall)]
	fake.categoriesArgsForCall = append(fake.categoriesArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.CategoriesStub
	fakeReturns := fake.categoriesReturns
	fake.recordInvocation("Categories", []interface{}{arg1})
	fake.categoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) CategoriesCallCount() int {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	return len(fake.categoriesArgsForCall)
}

func (fake *FakeWorkflow) CategoriesCalls(stub func(workflow.WorkflowParams) ([]string, error)) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = stub
}

func (fake *FakeWorkflow) CategoriesArgsForCall(i int) workflow.WorkflowParams {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	argsForCall := fake.categoriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) CategoriesReturns(result1 []string, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	fake.categoriesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) CategoriesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	if fake.categoriesReturnsOnCall == nil {
		fake.categoriesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.categoriesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Filter(arg1 *transformation.FilterParams, arg2 []*models.Product) ([]*models.Product, error) {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.filterMutex.Lock()
	ret, specificReturn := fake.filterReturnsOnCall[len(fake.filterArgsForCall)]
	fake.filterArgsForCall = append(fake.filterArgsForCall, struct {
		arg1 *transformation.FilterParams
		arg2 []*models.Product
	}{arg1, arg2Copy})
	stub := fake.FilterStub
	fakeReturns := fake.filterReturns
	fake.recordInvocation("Filter", []interface{}{arg1, arg2Copy})
	fake.filterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) FilterCallCount() int {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	return len(fake.filterArgsForCall)
}

func (fake *FakeWorkflow) FilterCalls(stub func(*transformation.FilterParams, []*models.Product) ([]*models.Product, error)) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = stub
}

func (fake *FakeWorkflow) FilterArgsForCall(i int) (*transformation.FilterParams, []*models.Product) {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	argsForCall := fake.filterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) FilterReturns(result1 []*models.Product, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	fake.filterReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) FilterReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	if fake.filterReturnsOnCall == nil {
		fake.filterReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.filterReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Location(arg1 workflow.WorkflowParams) (*models.Location, error) {
	fake.locationMutex.Lock()
	ret, specificReturn := fake.locationReturnsOnCall[len(fake.locationArgsForCall)]
	fake.locationArgsForCall = append(fake.locationArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.LocationStub
	fakeReturns := fake.locationReturns
	fake.recordInvocation("Location", []interface{}{arg1})
	fake.locationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) LocationCallCount() int {
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	return len(fake.locationArgsForCall)
}

func (fake *FakeWorkflow) LocationCalls(stub func(workflow.WorkflowParams) (*models.Location, error)) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = stub
}

func (fake *FakeWorkflow) LocationArgsForCall(i int) workflow.WorkflowParams {
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	argsForCall := fake.locationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) LocationReturns(result1 *models.Location, result2 error) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = nil
	fake.locationReturns = struct {
		result1 *models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LocationReturnsOnCall(i int, result1 *models.Location, result2 error) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = nil
	if fake.locationReturnsOnCall == nil {
		fake.locationReturnsOnCall = make(map[int]struct {
			result1 *models.Location
			result2 error
		})
	}
	fake.locationReturnsOnCall[i] = struct {
		result1 *models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Locations(arg1 workflow.WorkflowParams) ([]*models.Location, error) {
	fake.locationsMutex.Lock()
	ret, specificReturn := fake.locationsReturnsOnCall[len(fake.locationsArgsForCall)]
	fake.locationsArgsForCall = append(fake.locationsArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.LocationsStub
	fakeReturns := fake.locationsReturns
	fake.recordInvocation("Locations", []interface{}{arg1})
	fake.locationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) LocationsCallCount() int {
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	return len(fake.locationsArgsForCall)
}

func (fake *FakeWorkflow) LocationsCalls(stub func(workflow.WorkflowParams) ([]*models.Location, error)) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = stub
}

func (fake *FakeWorkflow) LocationsArgsForCall(i int) workflow.WorkflowParams {
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	argsForCall := fake.locationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) LocationsReturns(result1 []*models.Location, result2 error) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = nil
	fake.locationsReturns = struct {
		result1 []*models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LocationsReturnsOnCall(i int, result1 []*models.Location, result2 error) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = nil
	if fake.locationsReturnsOnCall == nil {
		fake.locationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Location
			result2 error
		})
	}
	fake.locationsReturnsOnCall[i] = struct {
		result1 []*models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LogError(arg1 error, arg2 context.Context) {
	fake.logErrorMutex.Lock()
	fake.logErrorArgsForCall = append(fake.logErrorArgsForCall, struct {
		arg1 error
		arg2 context.Context
	}{arg1, arg2})
	stub := fake.LogErrorStub
	fake.recordInvocation("LogError", []interface{}{arg1, arg2})
	fake.logErrorMutex.Unlock()
	if stub != nil {
		fake.LogErrorStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) LogErrorCallCount() int {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	return len(fake.logErrorArgsForCall)
}

func (fake *FakeWorkflow) LogErrorCalls(stub func(error, context.Context)) {
	fake.logErrorMutex.Lock()
	defer fake.logErrorMutex.Unlock()
	fake.LogErrorStub = stub
}

func (fake *FakeWorkflow) LogErrorArgsForCall(i int) (error, context.Context) {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	argsForCall := fake.logErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) Offers(arg1 workflow.WorkflowParams) ([]*models.Offer, error) {
	fake.offersMutex.Lock()
	ret, specificReturn := fake.offersReturnsOnCall[len(fake.offersArgsForCall)]
	fake.offersArgsForCall = append(fake.offersArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.OffersStub
	fakeReturns := fake.offersReturns
	fake.recordInvocation("Offers", []interface{}{arg1})
	fake.offersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) OffersCallCount() int {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	return len(fake.offersArgsForCall)
}

func (fake *FakeWorkflow) OffersCalls(stub func(workflow.WorkflowParams) ([]*models.Offer, error)) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = stub
}

func (fake *FakeWorkflow) OffersArgsForCall(i int) workflow.WorkflowParams {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	argsForCall := fake.offersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) OffersReturns(result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	fake.offersReturns = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) OffersReturnsOnCall(i int, result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	if fake.offersReturnsOnCall == nil {
		fake.offersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
			result2 error
		})
	}
	fake.offersReturnsOnCall[i] = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Product(arg1 workflow.WorkflowParams, arg2 string) (*models.Product, error) {
	fake.productMutex.Lock()
	ret, specificReturn := fake.productReturnsOnCall[len(fake.productArgsForCall)]
	fake.productArgsForCall = append(fake.productArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}{arg1, arg2})
	stub := fake.ProductStub
	fakeReturns := fake.productReturns
	fake.recordInvocation("Product", []interface{}{arg1, arg2})
	fake.productMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductCallCount() int {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	return len(fake.productArgsForCall)
}

func (fake *FakeWorkflow) ProductCalls(stub func(workflow.WorkflowParams, string) (*models.Product, error)) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = stub
}

func (fake *FakeWorkflow) ProductArgsForCall(i int) (workflow.WorkflowParams, string) {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	argsForCall := fake.productArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) ProductReturns(result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	fake.productReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	if fake.productReturnsOnCall == nil {
		fake.productReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.productReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Products(arg1 workflow.WorkflowParams) ([]*models.Product, error) {
	fake.productsMutex.Lock()
	ret, specificReturn := fake.productsReturnsOnCall[len(fake.productsArgsForCall)]
	fake.productsArgsForCall = append(fake.productsArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.ProductsStub
	fakeReturns := fake.productsReturns
	fake.recordInvocation("Products", []interface{}{arg1})
	fake.productsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsCallCount() int {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	return len(fake.productsArgsForCall)
}

func (fake *FakeWorkflow) ProductsCalls(stub func(workflow.WorkflowParams) ([]*models.Product, error)) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = stub
}

func (fake *FakeWorkflow) ProductsArgsForCall(i int) workflow.WorkflowParams {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	argsForCall := fake.productsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) ProductsReturns(result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	fake.productsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	if fake.productsReturnsOnCall == nil {
		fake.productsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsInCategory(arg1 workflow.WorkflowParams, arg2 string) ([]*models.Product, error) {
	fake.productsInCategoryMutex.Lock()
	ret, specificReturn := fake.productsInCategoryReturnsOnCall[len(fake.productsInCategoryArgsForCall)]
	fake.productsInCategoryArgsForCall = append(fake.productsInCategoryArgsForCall, struct {
		arg1 workflow.WorkflowParams
		arg2 string
	}{arg1, arg2})
	stub := fake.ProductsInCategoryStub
	fakeReturns := fake.productsInCategoryReturns
	fake.recordInvocation("ProductsInCategory", []interface{}{arg1, arg2})
	fake.productsInCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsInCategoryCallCount() int {
	fake.productsInCategoryMutex.RLock()
	defer fake.productsInCategoryMutex.RUnlock()
	return len(fake.productsInCategoryArgsForCall)
}

func (fake *FakeWorkflow) ProductsInCategoryCalls(stub func(workflow.WorkflowParams, string) ([]*models.Product, error)) {
	fake.productsInCategoryMutex.Lock()
	defer fake.productsInCategoryMutex.Unlock()
	fake.ProductsInCategoryStub = stub
}

func (fake *FakeWorkflow) ProductsInCategoryArgsForCall(i int) (workflow.WorkflowParams, string) {
	fake.productsInCategoryMutex.RLock()
	defer fake.productsInCategoryMutex.RUnlock()
	argsForCall := fake.productsInCategoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) ProductsInCategoryReturns(result1 []*models.Product, result2 error) {
	fake.productsInCategoryMutex.Lock()
	defer fake.productsInCategoryMutex.Unlock()
	fake.ProductsInCategoryStub = nil
	fake.productsInCategoryReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsInCategoryReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsInCategoryMutex.Lock()
	defer fake.productsInCategoryMutex.Unlock()
	fake.ProductsInCategoryStub = nil
	if fake.productsInCategoryReturnsOnCall == nil {
		fake.productsInCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsInCategoryReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Sort(arg1 *transformation.SortParams, arg2 []*models.Product) error {
	var arg2Copy []*models.Product
	if arg2 != nil {
		arg2Copy = make([]*models.Product, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sortMutex.Lock()
	ret, specificReturn := fake.sortReturnsOnCall[len(fake.sortArgsForCall)]
	fake.sortArgsForCall = append(fake.sortArgsForCall, struct {
		arg1 *transformation.SortParams
		arg2 []*models.Product
	}{arg1, arg2Copy})
	stub := fake.SortStub
	fakeReturns := fake.sortReturns
	fake.recordInvocation("Sort", []interface{}{arg1, arg2Copy})
	fake.sortMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkflow) SortCallCount() int {
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	return len(fake.sortArgsForCall)
}

func (fake *FakeWorkflow) SortCalls(stub func(*transformation.SortParams, []*models.Product) error) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = stub
}

func (fake *FakeWorkflow) SortArgsForCall(i int) (*transformation.SortParams, []*models.Product) {
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	argsForCall := fake.sortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) SortReturns(result1 error) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = nil
	fake.sortReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkflow) SortReturnsOnCall(i int, result1 error) {
	fake.sortMutex.Lock()
	defer fake.sortMutex.Unlock()
	fake.SortStub = nil
	if fake.sortReturnsOnCall == nil {
		fake.sortReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sortReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorkflow) Terpenes(arg1 workflow.WorkflowParams) ([]*models.Terpene, error) {
	fake.terpenesMutex.Lock()
	ret, specificReturn := fake.terpenesReturnsOnCall[len(fake.terpenesArgsForCall)]
	fake.terpenesArgsForCall = append(fake.terpenesArgsForCall, struct {
		arg1 workflow.WorkflowParams
	}{arg1})
	stub := fake.TerpenesStub
	fakeReturns := fake.terpenesReturns
	fake.recordInvocation("Terpenes", []interface{}{arg1})
	fake.terpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) TerpenesCallCount() int {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	return len(fake.terpenesArgsForCall)
}

func (fake *FakeWorkflow) TerpenesCalls(stub func(workflow.WorkflowParams) ([]*models.Terpene, error)) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = stub
}

func (fake *FakeWorkflow) TerpenesArgsForCall(i int) workflow.WorkflowParams {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	argsForCall := fake.terpenesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkflow) TerpenesReturns(result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	fake.terpenesReturns = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) TerpenesReturnsOnCall(i int, result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	if fake.terpenesReturnsOnCall == nil {
		fake.terpenesReturnsOnCall = make(map[int]struct {
			result1 []*models.Terpene
			result2 error
		})
	}
	fake.terpenesReturnsOnCall[i] = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	fake.productsInCategoryMutex.RLock()
	defer fake.productsInCategoryMutex.RUnlock()
	fake.sortMutex.RLock()
	defer fake.sortMutex.RUnlock()
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorkflow) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ workflow.Workflow = new(FakeWorkflow)
