// Code generated by counterfeiter. DO NOT EDIT.
package workflowfakes

import (
	"context"
	"sync"

	"github.com/Linkinlog/LeafListr/internal/models"
	"github.com/Linkinlog/LeafListr/internal/workflow"
)

type FakeWorkflow struct {
	CannabinoidsStub        func(string, string, string) ([]*models.Cannabinoid, error)
	cannabinoidsMutex       sync.RWMutex
	cannabinoidsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	cannabinoidsReturns struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	cannabinoidsReturnsOnCall map[int]struct {
		result1 []*models.Cannabinoid
		result2 error
	}
	CategoriesStub        func(string, string, string) ([]models.Category, error)
	categoriesMutex       sync.RWMutex
	categoriesArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	categoriesReturns struct {
		result1 []models.Category
		result2 error
	}
	categoriesReturnsOnCall map[int]struct {
		result1 []models.Category
		result2 error
	}
	LocationStub        func(string, string, string) (*models.Location, error)
	locationMutex       sync.RWMutex
	locationArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	locationReturns struct {
		result1 *models.Location
		result2 error
	}
	locationReturnsOnCall map[int]struct {
		result1 *models.Location
		result2 error
	}
	LocationsStub        func(string, string) ([]*models.Location, error)
	locationsMutex       sync.RWMutex
	locationsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	locationsReturns struct {
		result1 []*models.Location
		result2 error
	}
	locationsReturnsOnCall map[int]struct {
		result1 []*models.Location
		result2 error
	}
	LogErrorStub        func(error, context.Context)
	logErrorMutex       sync.RWMutex
	logErrorArgsForCall []struct {
		arg1 error
		arg2 context.Context
	}
	OffersStub        func(string, string, string) ([]*models.Offer, error)
	offersMutex       sync.RWMutex
	offersArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	offersReturns struct {
		result1 []*models.Offer
		result2 error
	}
	offersReturnsOnCall map[int]struct {
		result1 []*models.Offer
		result2 error
	}
	ProductStub        func(string, string, string, string) (*models.Product, error)
	productMutex       sync.RWMutex
	productArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	productReturns struct {
		result1 *models.Product
		result2 error
	}
	productReturnsOnCall map[int]struct {
		result1 *models.Product
		result2 error
	}
	ProductsStub        func(string, string, string) ([]*models.Product, error)
	productsMutex       sync.RWMutex
	productsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	productsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsExcludingBrandsStub        func(string, string, string, []*models.Product, []string) ([]*models.Product, error)
	productsExcludingBrandsMutex       sync.RWMutex
	productsExcludingBrandsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 []string
	}
	productsExcludingBrandsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsExcludingBrandsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForBrandsStub        func(string, string, string, []*models.Product, []string) ([]*models.Product, error)
	productsForBrandsMutex       sync.RWMutex
	productsForBrandsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 []string
	}
	productsForBrandsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForBrandsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForCategoryStub        func(string, string, string, models.Category) ([]*models.Product, error)
	productsForCategoryMutex       sync.RWMutex
	productsForCategoryArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 models.Category
	}
	productsForCategoryReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForCategoryReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForPriceRangeStub        func(string, string, string, []*models.Product, float64, float64) ([]*models.Product, error)
	productsForPriceRangeMutex       sync.RWMutex
	productsForPriceRangeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 float64
		arg6 float64
	}
	productsForPriceRangeReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForPriceRangeReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForSubCategoryStub        func(string, string, string, []*models.Product, string) ([]*models.Product, error)
	productsForSubCategoryMutex       sync.RWMutex
	productsForSubCategoryArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 string
	}
	productsForSubCategoryReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForSubCategoryReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	ProductsForVariantsStub        func(string, string, string, []*models.Product, []string) ([]*models.Product, error)
	productsForVariantsMutex       sync.RWMutex
	productsForVariantsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 []string
	}
	productsForVariantsReturns struct {
		result1 []*models.Product
		result2 error
	}
	productsForVariantsReturnsOnCall map[int]struct {
		result1 []*models.Product
		result2 error
	}
	SortProductsByPriceAscStub        func(string, string, string, []*models.Product)
	sortProductsByPriceAscMutex       sync.RWMutex
	sortProductsByPriceAscArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}
	SortProductsByPriceDescStub        func(string, string, string, []*models.Product)
	sortProductsByPriceDescMutex       sync.RWMutex
	sortProductsByPriceDescArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}
	SortProductsByTHCAscStub        func(string, string, string, []*models.Product)
	sortProductsByTHCAscMutex       sync.RWMutex
	sortProductsByTHCAscArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}
	SortProductsByTHCDescStub        func(string, string, string, []*models.Product)
	sortProductsByTHCDescMutex       sync.RWMutex
	sortProductsByTHCDescArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}
	SortProductsByTop3TerpsStub        func(string, string, string, []*models.Product, [3]string)
	sortProductsByTop3TerpsMutex       sync.RWMutex
	sortProductsByTop3TerpsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 [3]string
	}
	TerpenesStub        func(string, string, string) ([]*models.Terpene, error)
	terpenesMutex       sync.RWMutex
	terpenesArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	terpenesReturns struct {
		result1 []*models.Terpene
		result2 error
	}
	terpenesReturnsOnCall map[int]struct {
		result1 []*models.Terpene
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorkflow) Cannabinoids(arg1 string, arg2 string, arg3 string) ([]*models.Cannabinoid, error) {
	fake.cannabinoidsMutex.Lock()
	ret, specificReturn := fake.cannabinoidsReturnsOnCall[len(fake.cannabinoidsArgsForCall)]
	fake.cannabinoidsArgsForCall = append(fake.cannabinoidsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CannabinoidsStub
	fakeReturns := fake.cannabinoidsReturns
	fake.recordInvocation("Cannabinoids", []interface{}{arg1, arg2, arg3})
	fake.cannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) CannabinoidsCallCount() int {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	return len(fake.cannabinoidsArgsForCall)
}

func (fake *FakeWorkflow) CannabinoidsCalls(stub func(string, string, string) ([]*models.Cannabinoid, error)) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = stub
}

func (fake *FakeWorkflow) CannabinoidsArgsForCall(i int) (string, string, string) {
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	argsForCall := fake.cannabinoidsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) CannabinoidsReturns(result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	fake.cannabinoidsReturns = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) CannabinoidsReturnsOnCall(i int, result1 []*models.Cannabinoid, result2 error) {
	fake.cannabinoidsMutex.Lock()
	defer fake.cannabinoidsMutex.Unlock()
	fake.CannabinoidsStub = nil
	if fake.cannabinoidsReturnsOnCall == nil {
		fake.cannabinoidsReturnsOnCall = make(map[int]struct {
			result1 []*models.Cannabinoid
			result2 error
		})
	}
	fake.cannabinoidsReturnsOnCall[i] = struct {
		result1 []*models.Cannabinoid
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Categories(arg1 string, arg2 string, arg3 string) ([]models.Category, error) {
	fake.categoriesMutex.Lock()
	ret, specificReturn := fake.categoriesReturnsOnCall[len(fake.categoriesArgsForCall)]
	fake.categoriesArgsForCall = append(fake.categoriesArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CategoriesStub
	fakeReturns := fake.categoriesReturns
	fake.recordInvocation("Categories", []interface{}{arg1, arg2, arg3})
	fake.categoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) CategoriesCallCount() int {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	return len(fake.categoriesArgsForCall)
}

func (fake *FakeWorkflow) CategoriesCalls(stub func(string, string, string) ([]models.Category, error)) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = stub
}

func (fake *FakeWorkflow) CategoriesArgsForCall(i int) (string, string, string) {
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	argsForCall := fake.categoriesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) CategoriesReturns(result1 []models.Category, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	fake.categoriesReturns = struct {
		result1 []models.Category
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) CategoriesReturnsOnCall(i int, result1 []models.Category, result2 error) {
	fake.categoriesMutex.Lock()
	defer fake.categoriesMutex.Unlock()
	fake.CategoriesStub = nil
	if fake.categoriesReturnsOnCall == nil {
		fake.categoriesReturnsOnCall = make(map[int]struct {
			result1 []models.Category
			result2 error
		})
	}
	fake.categoriesReturnsOnCall[i] = struct {
		result1 []models.Category
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Location(arg1 string, arg2 string, arg3 string) (*models.Location, error) {
	fake.locationMutex.Lock()
	ret, specificReturn := fake.locationReturnsOnCall[len(fake.locationArgsForCall)]
	fake.locationArgsForCall = append(fake.locationArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.LocationStub
	fakeReturns := fake.locationReturns
	fake.recordInvocation("Location", []interface{}{arg1, arg2, arg3})
	fake.locationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) LocationCallCount() int {
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	return len(fake.locationArgsForCall)
}

func (fake *FakeWorkflow) LocationCalls(stub func(string, string, string) (*models.Location, error)) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = stub
}

func (fake *FakeWorkflow) LocationArgsForCall(i int) (string, string, string) {
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	argsForCall := fake.locationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) LocationReturns(result1 *models.Location, result2 error) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = nil
	fake.locationReturns = struct {
		result1 *models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LocationReturnsOnCall(i int, result1 *models.Location, result2 error) {
	fake.locationMutex.Lock()
	defer fake.locationMutex.Unlock()
	fake.LocationStub = nil
	if fake.locationReturnsOnCall == nil {
		fake.locationReturnsOnCall = make(map[int]struct {
			result1 *models.Location
			result2 error
		})
	}
	fake.locationReturnsOnCall[i] = struct {
		result1 *models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Locations(arg1 string, arg2 string) ([]*models.Location, error) {
	fake.locationsMutex.Lock()
	ret, specificReturn := fake.locationsReturnsOnCall[len(fake.locationsArgsForCall)]
	fake.locationsArgsForCall = append(fake.locationsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.LocationsStub
	fakeReturns := fake.locationsReturns
	fake.recordInvocation("Locations", []interface{}{arg1, arg2})
	fake.locationsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) LocationsCallCount() int {
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	return len(fake.locationsArgsForCall)
}

func (fake *FakeWorkflow) LocationsCalls(stub func(string, string) ([]*models.Location, error)) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = stub
}

func (fake *FakeWorkflow) LocationsArgsForCall(i int) (string, string) {
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	argsForCall := fake.locationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) LocationsReturns(result1 []*models.Location, result2 error) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = nil
	fake.locationsReturns = struct {
		result1 []*models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LocationsReturnsOnCall(i int, result1 []*models.Location, result2 error) {
	fake.locationsMutex.Lock()
	defer fake.locationsMutex.Unlock()
	fake.LocationsStub = nil
	if fake.locationsReturnsOnCall == nil {
		fake.locationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Location
			result2 error
		})
	}
	fake.locationsReturnsOnCall[i] = struct {
		result1 []*models.Location
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) LogError(arg1 error, arg2 context.Context) {
	fake.logErrorMutex.Lock()
	fake.logErrorArgsForCall = append(fake.logErrorArgsForCall, struct {
		arg1 error
		arg2 context.Context
	}{arg1, arg2})
	stub := fake.LogErrorStub
	fake.recordInvocation("LogError", []interface{}{arg1, arg2})
	fake.logErrorMutex.Unlock()
	if stub != nil {
		fake.LogErrorStub(arg1, arg2)
	}
}

func (fake *FakeWorkflow) LogErrorCallCount() int {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	return len(fake.logErrorArgsForCall)
}

func (fake *FakeWorkflow) LogErrorCalls(stub func(error, context.Context)) {
	fake.logErrorMutex.Lock()
	defer fake.logErrorMutex.Unlock()
	fake.LogErrorStub = stub
}

func (fake *FakeWorkflow) LogErrorArgsForCall(i int) (error, context.Context) {
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	argsForCall := fake.logErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkflow) Offers(arg1 string, arg2 string, arg3 string) ([]*models.Offer, error) {
	fake.offersMutex.Lock()
	ret, specificReturn := fake.offersReturnsOnCall[len(fake.offersArgsForCall)]
	fake.offersArgsForCall = append(fake.offersArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.OffersStub
	fakeReturns := fake.offersReturns
	fake.recordInvocation("Offers", []interface{}{arg1, arg2, arg3})
	fake.offersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) OffersCallCount() int {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	return len(fake.offersArgsForCall)
}

func (fake *FakeWorkflow) OffersCalls(stub func(string, string, string) ([]*models.Offer, error)) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = stub
}

func (fake *FakeWorkflow) OffersArgsForCall(i int) (string, string, string) {
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	argsForCall := fake.offersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) OffersReturns(result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	fake.offersReturns = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) OffersReturnsOnCall(i int, result1 []*models.Offer, result2 error) {
	fake.offersMutex.Lock()
	defer fake.offersMutex.Unlock()
	fake.OffersStub = nil
	if fake.offersReturnsOnCall == nil {
		fake.offersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
			result2 error
		})
	}
	fake.offersReturnsOnCall[i] = struct {
		result1 []*models.Offer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Product(arg1 string, arg2 string, arg3 string, arg4 string) (*models.Product, error) {
	fake.productMutex.Lock()
	ret, specificReturn := fake.productReturnsOnCall[len(fake.productArgsForCall)]
	fake.productArgsForCall = append(fake.productArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ProductStub
	fakeReturns := fake.productReturns
	fake.recordInvocation("Product", []interface{}{arg1, arg2, arg3, arg4})
	fake.productMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductCallCount() int {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	return len(fake.productArgsForCall)
}

func (fake *FakeWorkflow) ProductCalls(stub func(string, string, string, string) (*models.Product, error)) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = stub
}

func (fake *FakeWorkflow) ProductArgsForCall(i int) (string, string, string, string) {
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	argsForCall := fake.productArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) ProductReturns(result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	fake.productReturns = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductReturnsOnCall(i int, result1 *models.Product, result2 error) {
	fake.productMutex.Lock()
	defer fake.productMutex.Unlock()
	fake.ProductStub = nil
	if fake.productReturnsOnCall == nil {
		fake.productReturnsOnCall = make(map[int]struct {
			result1 *models.Product
			result2 error
		})
	}
	fake.productReturnsOnCall[i] = struct {
		result1 *models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Products(arg1 string, arg2 string, arg3 string) ([]*models.Product, error) {
	fake.productsMutex.Lock()
	ret, specificReturn := fake.productsReturnsOnCall[len(fake.productsArgsForCall)]
	fake.productsArgsForCall = append(fake.productsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ProductsStub
	fakeReturns := fake.productsReturns
	fake.recordInvocation("Products", []interface{}{arg1, arg2, arg3})
	fake.productsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsCallCount() int {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	return len(fake.productsArgsForCall)
}

func (fake *FakeWorkflow) ProductsCalls(stub func(string, string, string) ([]*models.Product, error)) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = stub
}

func (fake *FakeWorkflow) ProductsArgsForCall(i int) (string, string, string) {
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	argsForCall := fake.productsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) ProductsReturns(result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	fake.productsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsMutex.Lock()
	defer fake.productsMutex.Unlock()
	fake.ProductsStub = nil
	if fake.productsReturnsOnCall == nil {
		fake.productsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsExcludingBrands(arg1 string, arg2 string, arg3 string, arg4 []*models.Product, arg5 []string) ([]*models.Product, error) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.productsExcludingBrandsMutex.Lock()
	ret, specificReturn := fake.productsExcludingBrandsReturnsOnCall[len(fake.productsExcludingBrandsArgsForCall)]
	fake.productsExcludingBrandsArgsForCall = append(fake.productsExcludingBrandsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 []string
	}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	stub := fake.ProductsExcludingBrandsStub
	fakeReturns := fake.productsExcludingBrandsReturns
	fake.recordInvocation("ProductsExcludingBrands", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.productsExcludingBrandsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsExcludingBrandsCallCount() int {
	fake.productsExcludingBrandsMutex.RLock()
	defer fake.productsExcludingBrandsMutex.RUnlock()
	return len(fake.productsExcludingBrandsArgsForCall)
}

func (fake *FakeWorkflow) ProductsExcludingBrandsCalls(stub func(string, string, string, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsExcludingBrandsMutex.Lock()
	defer fake.productsExcludingBrandsMutex.Unlock()
	fake.ProductsExcludingBrandsStub = stub
}

func (fake *FakeWorkflow) ProductsExcludingBrandsArgsForCall(i int) (string, string, string, []*models.Product, []string) {
	fake.productsExcludingBrandsMutex.RLock()
	defer fake.productsExcludingBrandsMutex.RUnlock()
	argsForCall := fake.productsExcludingBrandsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorkflow) ProductsExcludingBrandsReturns(result1 []*models.Product, result2 error) {
	fake.productsExcludingBrandsMutex.Lock()
	defer fake.productsExcludingBrandsMutex.Unlock()
	fake.ProductsExcludingBrandsStub = nil
	fake.productsExcludingBrandsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsExcludingBrandsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsExcludingBrandsMutex.Lock()
	defer fake.productsExcludingBrandsMutex.Unlock()
	fake.ProductsExcludingBrandsStub = nil
	if fake.productsExcludingBrandsReturnsOnCall == nil {
		fake.productsExcludingBrandsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsExcludingBrandsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForBrands(arg1 string, arg2 string, arg3 string, arg4 []*models.Product, arg5 []string) ([]*models.Product, error) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.productsForBrandsMutex.Lock()
	ret, specificReturn := fake.productsForBrandsReturnsOnCall[len(fake.productsForBrandsArgsForCall)]
	fake.productsForBrandsArgsForCall = append(fake.productsForBrandsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 []string
	}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	stub := fake.ProductsForBrandsStub
	fakeReturns := fake.productsForBrandsReturns
	fake.recordInvocation("ProductsForBrands", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.productsForBrandsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForBrandsCallCount() int {
	fake.productsForBrandsMutex.RLock()
	defer fake.productsForBrandsMutex.RUnlock()
	return len(fake.productsForBrandsArgsForCall)
}

func (fake *FakeWorkflow) ProductsForBrandsCalls(stub func(string, string, string, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsForBrandsMutex.Lock()
	defer fake.productsForBrandsMutex.Unlock()
	fake.ProductsForBrandsStub = stub
}

func (fake *FakeWorkflow) ProductsForBrandsArgsForCall(i int) (string, string, string, []*models.Product, []string) {
	fake.productsForBrandsMutex.RLock()
	defer fake.productsForBrandsMutex.RUnlock()
	argsForCall := fake.productsForBrandsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorkflow) ProductsForBrandsReturns(result1 []*models.Product, result2 error) {
	fake.productsForBrandsMutex.Lock()
	defer fake.productsForBrandsMutex.Unlock()
	fake.ProductsForBrandsStub = nil
	fake.productsForBrandsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForBrandsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForBrandsMutex.Lock()
	defer fake.productsForBrandsMutex.Unlock()
	fake.ProductsForBrandsStub = nil
	if fake.productsForBrandsReturnsOnCall == nil {
		fake.productsForBrandsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForBrandsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForCategory(arg1 string, arg2 string, arg3 string, arg4 models.Category) ([]*models.Product, error) {
	fake.productsForCategoryMutex.Lock()
	ret, specificReturn := fake.productsForCategoryReturnsOnCall[len(fake.productsForCategoryArgsForCall)]
	fake.productsForCategoryArgsForCall = append(fake.productsForCategoryArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 models.Category
	}{arg1, arg2, arg3, arg4})
	stub := fake.ProductsForCategoryStub
	fakeReturns := fake.productsForCategoryReturns
	fake.recordInvocation("ProductsForCategory", []interface{}{arg1, arg2, arg3, arg4})
	fake.productsForCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForCategoryCallCount() int {
	fake.productsForCategoryMutex.RLock()
	defer fake.productsForCategoryMutex.RUnlock()
	return len(fake.productsForCategoryArgsForCall)
}

func (fake *FakeWorkflow) ProductsForCategoryCalls(stub func(string, string, string, models.Category) ([]*models.Product, error)) {
	fake.productsForCategoryMutex.Lock()
	defer fake.productsForCategoryMutex.Unlock()
	fake.ProductsForCategoryStub = stub
}

func (fake *FakeWorkflow) ProductsForCategoryArgsForCall(i int) (string, string, string, models.Category) {
	fake.productsForCategoryMutex.RLock()
	defer fake.productsForCategoryMutex.RUnlock()
	argsForCall := fake.productsForCategoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) ProductsForCategoryReturns(result1 []*models.Product, result2 error) {
	fake.productsForCategoryMutex.Lock()
	defer fake.productsForCategoryMutex.Unlock()
	fake.ProductsForCategoryStub = nil
	fake.productsForCategoryReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForCategoryReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForCategoryMutex.Lock()
	defer fake.productsForCategoryMutex.Unlock()
	fake.ProductsForCategoryStub = nil
	if fake.productsForCategoryReturnsOnCall == nil {
		fake.productsForCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForCategoryReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForPriceRange(arg1 string, arg2 string, arg3 string, arg4 []*models.Product, arg5 float64, arg6 float64) ([]*models.Product, error) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.productsForPriceRangeMutex.Lock()
	ret, specificReturn := fake.productsForPriceRangeReturnsOnCall[len(fake.productsForPriceRangeArgsForCall)]
	fake.productsForPriceRangeArgsForCall = append(fake.productsForPriceRangeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 float64
		arg6 float64
	}{arg1, arg2, arg3, arg4Copy, arg5, arg6})
	stub := fake.ProductsForPriceRangeStub
	fakeReturns := fake.productsForPriceRangeReturns
	fake.recordInvocation("ProductsForPriceRange", []interface{}{arg1, arg2, arg3, arg4Copy, arg5, arg6})
	fake.productsForPriceRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForPriceRangeCallCount() int {
	fake.productsForPriceRangeMutex.RLock()
	defer fake.productsForPriceRangeMutex.RUnlock()
	return len(fake.productsForPriceRangeArgsForCall)
}

func (fake *FakeWorkflow) ProductsForPriceRangeCalls(stub func(string, string, string, []*models.Product, float64, float64) ([]*models.Product, error)) {
	fake.productsForPriceRangeMutex.Lock()
	defer fake.productsForPriceRangeMutex.Unlock()
	fake.ProductsForPriceRangeStub = stub
}

func (fake *FakeWorkflow) ProductsForPriceRangeArgsForCall(i int) (string, string, string, []*models.Product, float64, float64) {
	fake.productsForPriceRangeMutex.RLock()
	defer fake.productsForPriceRangeMutex.RUnlock()
	argsForCall := fake.productsForPriceRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeWorkflow) ProductsForPriceRangeReturns(result1 []*models.Product, result2 error) {
	fake.productsForPriceRangeMutex.Lock()
	defer fake.productsForPriceRangeMutex.Unlock()
	fake.ProductsForPriceRangeStub = nil
	fake.productsForPriceRangeReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForPriceRangeReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForPriceRangeMutex.Lock()
	defer fake.productsForPriceRangeMutex.Unlock()
	fake.ProductsForPriceRangeStub = nil
	if fake.productsForPriceRangeReturnsOnCall == nil {
		fake.productsForPriceRangeReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForPriceRangeReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForSubCategory(arg1 string, arg2 string, arg3 string, arg4 []*models.Product, arg5 string) ([]*models.Product, error) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.productsForSubCategoryMutex.Lock()
	ret, specificReturn := fake.productsForSubCategoryReturnsOnCall[len(fake.productsForSubCategoryArgsForCall)]
	fake.productsForSubCategoryArgsForCall = append(fake.productsForSubCategoryArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 string
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.ProductsForSubCategoryStub
	fakeReturns := fake.productsForSubCategoryReturns
	fake.recordInvocation("ProductsForSubCategory", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.productsForSubCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForSubCategoryCallCount() int {
	fake.productsForSubCategoryMutex.RLock()
	defer fake.productsForSubCategoryMutex.RUnlock()
	return len(fake.productsForSubCategoryArgsForCall)
}

func (fake *FakeWorkflow) ProductsForSubCategoryCalls(stub func(string, string, string, []*models.Product, string) ([]*models.Product, error)) {
	fake.productsForSubCategoryMutex.Lock()
	defer fake.productsForSubCategoryMutex.Unlock()
	fake.ProductsForSubCategoryStub = stub
}

func (fake *FakeWorkflow) ProductsForSubCategoryArgsForCall(i int) (string, string, string, []*models.Product, string) {
	fake.productsForSubCategoryMutex.RLock()
	defer fake.productsForSubCategoryMutex.RUnlock()
	argsForCall := fake.productsForSubCategoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorkflow) ProductsForSubCategoryReturns(result1 []*models.Product, result2 error) {
	fake.productsForSubCategoryMutex.Lock()
	defer fake.productsForSubCategoryMutex.Unlock()
	fake.ProductsForSubCategoryStub = nil
	fake.productsForSubCategoryReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForSubCategoryReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForSubCategoryMutex.Lock()
	defer fake.productsForSubCategoryMutex.Unlock()
	fake.ProductsForSubCategoryStub = nil
	if fake.productsForSubCategoryReturnsOnCall == nil {
		fake.productsForSubCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForSubCategoryReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForVariants(arg1 string, arg2 string, arg3 string, arg4 []*models.Product, arg5 []string) ([]*models.Product, error) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.productsForVariantsMutex.Lock()
	ret, specificReturn := fake.productsForVariantsReturnsOnCall[len(fake.productsForVariantsArgsForCall)]
	fake.productsForVariantsArgsForCall = append(fake.productsForVariantsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 []string
	}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	stub := fake.ProductsForVariantsStub
	fakeReturns := fake.productsForVariantsReturns
	fake.recordInvocation("ProductsForVariants", []interface{}{arg1, arg2, arg3, arg4Copy, arg5Copy})
	fake.productsForVariantsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) ProductsForVariantsCallCount() int {
	fake.productsForVariantsMutex.RLock()
	defer fake.productsForVariantsMutex.RUnlock()
	return len(fake.productsForVariantsArgsForCall)
}

func (fake *FakeWorkflow) ProductsForVariantsCalls(stub func(string, string, string, []*models.Product, []string) ([]*models.Product, error)) {
	fake.productsForVariantsMutex.Lock()
	defer fake.productsForVariantsMutex.Unlock()
	fake.ProductsForVariantsStub = stub
}

func (fake *FakeWorkflow) ProductsForVariantsArgsForCall(i int) (string, string, string, []*models.Product, []string) {
	fake.productsForVariantsMutex.RLock()
	defer fake.productsForVariantsMutex.RUnlock()
	argsForCall := fake.productsForVariantsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorkflow) ProductsForVariantsReturns(result1 []*models.Product, result2 error) {
	fake.productsForVariantsMutex.Lock()
	defer fake.productsForVariantsMutex.Unlock()
	fake.ProductsForVariantsStub = nil
	fake.productsForVariantsReturns = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) ProductsForVariantsReturnsOnCall(i int, result1 []*models.Product, result2 error) {
	fake.productsForVariantsMutex.Lock()
	defer fake.productsForVariantsMutex.Unlock()
	fake.ProductsForVariantsStub = nil
	if fake.productsForVariantsReturnsOnCall == nil {
		fake.productsForVariantsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
			result2 error
		})
	}
	fake.productsForVariantsReturnsOnCall[i] = struct {
		result1 []*models.Product
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) SortProductsByPriceAsc(arg1 string, arg2 string, arg3 string, arg4 []*models.Product) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.sortProductsByPriceAscMutex.Lock()
	fake.sortProductsByPriceAscArgsForCall = append(fake.sortProductsByPriceAscArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.SortProductsByPriceAscStub
	fake.recordInvocation("SortProductsByPriceAsc", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.sortProductsByPriceAscMutex.Unlock()
	if stub != nil {
		fake.SortProductsByPriceAscStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeWorkflow) SortProductsByPriceAscCallCount() int {
	fake.sortProductsByPriceAscMutex.RLock()
	defer fake.sortProductsByPriceAscMutex.RUnlock()
	return len(fake.sortProductsByPriceAscArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByPriceAscCalls(stub func(string, string, string, []*models.Product)) {
	fake.sortProductsByPriceAscMutex.Lock()
	defer fake.sortProductsByPriceAscMutex.Unlock()
	fake.SortProductsByPriceAscStub = stub
}

func (fake *FakeWorkflow) SortProductsByPriceAscArgsForCall(i int) (string, string, string, []*models.Product) {
	fake.sortProductsByPriceAscMutex.RLock()
	defer fake.sortProductsByPriceAscMutex.RUnlock()
	argsForCall := fake.sortProductsByPriceAscArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) SortProductsByPriceDesc(arg1 string, arg2 string, arg3 string, arg4 []*models.Product) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.sortProductsByPriceDescMutex.Lock()
	fake.sortProductsByPriceDescArgsForCall = append(fake.sortProductsByPriceDescArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.SortProductsByPriceDescStub
	fake.recordInvocation("SortProductsByPriceDesc", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.sortProductsByPriceDescMutex.Unlock()
	if stub != nil {
		fake.SortProductsByPriceDescStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeWorkflow) SortProductsByPriceDescCallCount() int {
	fake.sortProductsByPriceDescMutex.RLock()
	defer fake.sortProductsByPriceDescMutex.RUnlock()
	return len(fake.sortProductsByPriceDescArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByPriceDescCalls(stub func(string, string, string, []*models.Product)) {
	fake.sortProductsByPriceDescMutex.Lock()
	defer fake.sortProductsByPriceDescMutex.Unlock()
	fake.SortProductsByPriceDescStub = stub
}

func (fake *FakeWorkflow) SortProductsByPriceDescArgsForCall(i int) (string, string, string, []*models.Product) {
	fake.sortProductsByPriceDescMutex.RLock()
	defer fake.sortProductsByPriceDescMutex.RUnlock()
	argsForCall := fake.sortProductsByPriceDescArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) SortProductsByTHCAsc(arg1 string, arg2 string, arg3 string, arg4 []*models.Product) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.sortProductsByTHCAscMutex.Lock()
	fake.sortProductsByTHCAscArgsForCall = append(fake.sortProductsByTHCAscArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.SortProductsByTHCAscStub
	fake.recordInvocation("SortProductsByTHCAsc", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.sortProductsByTHCAscMutex.Unlock()
	if stub != nil {
		fake.SortProductsByTHCAscStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeWorkflow) SortProductsByTHCAscCallCount() int {
	fake.sortProductsByTHCAscMutex.RLock()
	defer fake.sortProductsByTHCAscMutex.RUnlock()
	return len(fake.sortProductsByTHCAscArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByTHCAscCalls(stub func(string, string, string, []*models.Product)) {
	fake.sortProductsByTHCAscMutex.Lock()
	defer fake.sortProductsByTHCAscMutex.Unlock()
	fake.SortProductsByTHCAscStub = stub
}

func (fake *FakeWorkflow) SortProductsByTHCAscArgsForCall(i int) (string, string, string, []*models.Product) {
	fake.sortProductsByTHCAscMutex.RLock()
	defer fake.sortProductsByTHCAscMutex.RUnlock()
	argsForCall := fake.sortProductsByTHCAscArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) SortProductsByTHCDesc(arg1 string, arg2 string, arg3 string, arg4 []*models.Product) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.sortProductsByTHCDescMutex.Lock()
	fake.sortProductsByTHCDescArgsForCall = append(fake.sortProductsByTHCDescArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.SortProductsByTHCDescStub
	fake.recordInvocation("SortProductsByTHCDesc", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.sortProductsByTHCDescMutex.Unlock()
	if stub != nil {
		fake.SortProductsByTHCDescStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeWorkflow) SortProductsByTHCDescCallCount() int {
	fake.sortProductsByTHCDescMutex.RLock()
	defer fake.sortProductsByTHCDescMutex.RUnlock()
	return len(fake.sortProductsByTHCDescArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByTHCDescCalls(stub func(string, string, string, []*models.Product)) {
	fake.sortProductsByTHCDescMutex.Lock()
	defer fake.sortProductsByTHCDescMutex.Unlock()
	fake.SortProductsByTHCDescStub = stub
}

func (fake *FakeWorkflow) SortProductsByTHCDescArgsForCall(i int) (string, string, string, []*models.Product) {
	fake.sortProductsByTHCDescMutex.RLock()
	defer fake.sortProductsByTHCDescMutex.RUnlock()
	argsForCall := fake.sortProductsByTHCDescArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeWorkflow) SortProductsByTop3Terps(arg1 string, arg2 string, arg3 string, arg4 []*models.Product, arg5 [3]string) {
	var arg4Copy []*models.Product
	if arg4 != nil {
		arg4Copy = make([]*models.Product, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.sortProductsByTop3TerpsMutex.Lock()
	fake.sortProductsByTop3TerpsArgsForCall = append(fake.sortProductsByTop3TerpsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []*models.Product
		arg5 [3]string
	}{arg1, arg2, arg3, arg4Copy, arg5})
	stub := fake.SortProductsByTop3TerpsStub
	fake.recordInvocation("SortProductsByTop3Terps", []interface{}{arg1, arg2, arg3, arg4Copy, arg5})
	fake.sortProductsByTop3TerpsMutex.Unlock()
	if stub != nil {
		fake.SortProductsByTop3TerpsStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeWorkflow) SortProductsByTop3TerpsCallCount() int {
	fake.sortProductsByTop3TerpsMutex.RLock()
	defer fake.sortProductsByTop3TerpsMutex.RUnlock()
	return len(fake.sortProductsByTop3TerpsArgsForCall)
}

func (fake *FakeWorkflow) SortProductsByTop3TerpsCalls(stub func(string, string, string, []*models.Product, [3]string)) {
	fake.sortProductsByTop3TerpsMutex.Lock()
	defer fake.sortProductsByTop3TerpsMutex.Unlock()
	fake.SortProductsByTop3TerpsStub = stub
}

func (fake *FakeWorkflow) SortProductsByTop3TerpsArgsForCall(i int) (string, string, string, []*models.Product, [3]string) {
	fake.sortProductsByTop3TerpsMutex.RLock()
	defer fake.sortProductsByTop3TerpsMutex.RUnlock()
	argsForCall := fake.sortProductsByTop3TerpsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeWorkflow) Terpenes(arg1 string, arg2 string, arg3 string) ([]*models.Terpene, error) {
	fake.terpenesMutex.Lock()
	ret, specificReturn := fake.terpenesReturnsOnCall[len(fake.terpenesArgsForCall)]
	fake.terpenesArgsForCall = append(fake.terpenesArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.TerpenesStub
	fakeReturns := fake.terpenesReturns
	fake.recordInvocation("Terpenes", []interface{}{arg1, arg2, arg3})
	fake.terpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorkflow) TerpenesCallCount() int {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	return len(fake.terpenesArgsForCall)
}

func (fake *FakeWorkflow) TerpenesCalls(stub func(string, string, string) ([]*models.Terpene, error)) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = stub
}

func (fake *FakeWorkflow) TerpenesArgsForCall(i int) (string, string, string) {
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	argsForCall := fake.terpenesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeWorkflow) TerpenesReturns(result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	fake.terpenesReturns = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) TerpenesReturnsOnCall(i int, result1 []*models.Terpene, result2 error) {
	fake.terpenesMutex.Lock()
	defer fake.terpenesMutex.Unlock()
	fake.TerpenesStub = nil
	if fake.terpenesReturnsOnCall == nil {
		fake.terpenesReturnsOnCall = make(map[int]struct {
			result1 []*models.Terpene
			result2 error
		})
	}
	fake.terpenesReturnsOnCall[i] = struct {
		result1 []*models.Terpene
		result2 error
	}{result1, result2}
}

func (fake *FakeWorkflow) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cannabinoidsMutex.RLock()
	defer fake.cannabinoidsMutex.RUnlock()
	fake.categoriesMutex.RLock()
	defer fake.categoriesMutex.RUnlock()
	fake.locationMutex.RLock()
	defer fake.locationMutex.RUnlock()
	fake.locationsMutex.RLock()
	defer fake.locationsMutex.RUnlock()
	fake.logErrorMutex.RLock()
	defer fake.logErrorMutex.RUnlock()
	fake.offersMutex.RLock()
	defer fake.offersMutex.RUnlock()
	fake.productMutex.RLock()
	defer fake.productMutex.RUnlock()
	fake.productsMutex.RLock()
	defer fake.productsMutex.RUnlock()
	fake.productsExcludingBrandsMutex.RLock()
	defer fake.productsExcludingBrandsMutex.RUnlock()
	fake.productsForBrandsMutex.RLock()
	defer fake.productsForBrandsMutex.RUnlock()
	fake.productsForCategoryMutex.RLock()
	defer fake.productsForCategoryMutex.RUnlock()
	fake.productsForPriceRangeMutex.RLock()
	defer fake.productsForPriceRangeMutex.RUnlock()
	fake.productsForSubCategoryMutex.RLock()
	defer fake.productsForSubCategoryMutex.RUnlock()
	fake.productsForVariantsMutex.RLock()
	defer fake.productsForVariantsMutex.RUnlock()
	fake.sortProductsByPriceAscMutex.RLock()
	defer fake.sortProductsByPriceAscMutex.RUnlock()
	fake.sortProductsByPriceDescMutex.RLock()
	defer fake.sortProductsByPriceDescMutex.RUnlock()
	fake.sortProductsByTHCAscMutex.RLock()
	defer fake.sortProductsByTHCAscMutex.RUnlock()
	fake.sortProductsByTHCDescMutex.RLock()
	defer fake.sortProductsByTHCDescMutex.RUnlock()
	fake.sortProductsByTop3TerpsMutex.RLock()
	defer fake.sortProductsByTop3TerpsMutex.RUnlock()
	fake.terpenesMutex.RLock()
	defer fake.terpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorkflow) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ workflow.Workflow = new(FakeWorkflow)
