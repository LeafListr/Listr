// Code generated by counterfeiter. DO NOT EDIT.
package translationfakes

import (
	"sync"

	"github.com/Linkinlog/LeafListr/internal/api/models"
	modelsa "github.com/Linkinlog/LeafListr/internal/models"
	"github.com/Linkinlog/LeafListr/internal/translation"
)

type FakeAPITranslatable struct {
	TranslateCannabinoidStub        func(*modelsa.Cannabinoid) *models.Cannabinoid
	translateCannabinoidMutex       sync.RWMutex
	translateCannabinoidArgsForCall []struct {
		arg1 *modelsa.Cannabinoid
	}
	translateCannabinoidReturns struct {
		result1 *models.Cannabinoid
	}
	translateCannabinoidReturnsOnCall map[int]struct {
		result1 *models.Cannabinoid
	}
	TranslateCannabinoidsStub        func([]*modelsa.Cannabinoid) []*models.Cannabinoid
	translateCannabinoidsMutex       sync.RWMutex
	translateCannabinoidsArgsForCall []struct {
		arg1 []*modelsa.Cannabinoid
	}
	translateCannabinoidsReturns struct {
		result1 []*models.Cannabinoid
	}
	translateCannabinoidsReturnsOnCall map[int]struct {
		result1 []*models.Cannabinoid
	}
	TranslateCategoriesStub        func([]string) []string
	translateCategoriesMutex       sync.RWMutex
	translateCategoriesArgsForCall []struct {
		arg1 []string
	}
	translateCategoriesReturns struct {
		result1 []string
	}
	translateCategoriesReturnsOnCall map[int]struct {
		result1 []string
	}
	TranslateCategoryStub        func(string) string
	translateCategoryMutex       sync.RWMutex
	translateCategoryArgsForCall []struct {
		arg1 string
	}
	translateCategoryReturns struct {
		result1 string
	}
	translateCategoryReturnsOnCall map[int]struct {
		result1 string
	}
	TranslateDispensariesStub        func([]*modelsa.Dispensary) []*models.Dispensary
	translateDispensariesMutex       sync.RWMutex
	translateDispensariesArgsForCall []struct {
		arg1 []*modelsa.Dispensary
	}
	translateDispensariesReturns struct {
		result1 []*models.Dispensary
	}
	translateDispensariesReturnsOnCall map[int]struct {
		result1 []*models.Dispensary
	}
	TranslateDispensaryStub        func(*modelsa.Dispensary) *models.Dispensary
	translateDispensaryMutex       sync.RWMutex
	translateDispensaryArgsForCall []struct {
		arg1 *modelsa.Dispensary
	}
	translateDispensaryReturns struct {
		result1 *models.Dispensary
	}
	translateDispensaryReturnsOnCall map[int]struct {
		result1 *models.Dispensary
	}
	TranslateLocationStub        func(*modelsa.Location) *models.Location
	translateLocationMutex       sync.RWMutex
	translateLocationArgsForCall []struct {
		arg1 *modelsa.Location
	}
	translateLocationReturns struct {
		result1 *models.Location
	}
	translateLocationReturnsOnCall map[int]struct {
		result1 *models.Location
	}
	TranslateLocationsStub        func([]*modelsa.Location) []*models.Location
	translateLocationsMutex       sync.RWMutex
	translateLocationsArgsForCall []struct {
		arg1 []*modelsa.Location
	}
	translateLocationsReturns struct {
		result1 []*models.Location
	}
	translateLocationsReturnsOnCall map[int]struct {
		result1 []*models.Location
	}
	TranslateOfferStub        func(*modelsa.Offer) *models.Offer
	translateOfferMutex       sync.RWMutex
	translateOfferArgsForCall []struct {
		arg1 *modelsa.Offer
	}
	translateOfferReturns struct {
		result1 *models.Offer
	}
	translateOfferReturnsOnCall map[int]struct {
		result1 *models.Offer
	}
	TranslateOffersStub        func([]*modelsa.Offer) []*models.Offer
	translateOffersMutex       sync.RWMutex
	translateOffersArgsForCall []struct {
		arg1 []*modelsa.Offer
	}
	translateOffersReturns struct {
		result1 []*models.Offer
	}
	translateOffersReturnsOnCall map[int]struct {
		result1 []*models.Offer
	}
	TranslateProductStub        func(*modelsa.Product) *models.Product
	translateProductMutex       sync.RWMutex
	translateProductArgsForCall []struct {
		arg1 *modelsa.Product
	}
	translateProductReturns struct {
		result1 *models.Product
	}
	translateProductReturnsOnCall map[int]struct {
		result1 *models.Product
	}
	TranslateProductsStub        func([]*modelsa.Product) []*models.Product
	translateProductsMutex       sync.RWMutex
	translateProductsArgsForCall []struct {
		arg1 []*modelsa.Product
	}
	translateProductsReturns struct {
		result1 []*models.Product
	}
	translateProductsReturnsOnCall map[int]struct {
		result1 []*models.Product
	}
	TranslateTerpeneStub        func(*modelsa.Terpene) *models.Terpene
	translateTerpeneMutex       sync.RWMutex
	translateTerpeneArgsForCall []struct {
		arg1 *modelsa.Terpene
	}
	translateTerpeneReturns struct {
		result1 *models.Terpene
	}
	translateTerpeneReturnsOnCall map[int]struct {
		result1 *models.Terpene
	}
	TranslateTerpenesStub        func([]*modelsa.Terpene) []*models.Terpene
	translateTerpenesMutex       sync.RWMutex
	translateTerpenesArgsForCall []struct {
		arg1 []*modelsa.Terpene
	}
	translateTerpenesReturns struct {
		result1 []*models.Terpene
	}
	translateTerpenesReturnsOnCall map[int]struct {
		result1 []*models.Terpene
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAPITranslatable) TranslateCannabinoid(arg1 *modelsa.Cannabinoid) *models.Cannabinoid {
	fake.translateCannabinoidMutex.Lock()
	ret, specificReturn := fake.translateCannabinoidReturnsOnCall[len(fake.translateCannabinoidArgsForCall)]
	fake.translateCannabinoidArgsForCall = append(fake.translateCannabinoidArgsForCall, struct {
		arg1 *modelsa.Cannabinoid
	}{arg1})
	stub := fake.TranslateCannabinoidStub
	fakeReturns := fake.translateCannabinoidReturns
	fake.recordInvocation("TranslateCannabinoid", []interface{}{arg1})
	fake.translateCannabinoidMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateCannabinoidCallCount() int {
	fake.translateCannabinoidMutex.RLock()
	defer fake.translateCannabinoidMutex.RUnlock()
	return len(fake.translateCannabinoidArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateCannabinoidCalls(stub func(*modelsa.Cannabinoid) *models.Cannabinoid) {
	fake.translateCannabinoidMutex.Lock()
	defer fake.translateCannabinoidMutex.Unlock()
	fake.TranslateCannabinoidStub = stub
}

func (fake *FakeAPITranslatable) TranslateCannabinoidArgsForCall(i int) *modelsa.Cannabinoid {
	fake.translateCannabinoidMutex.RLock()
	defer fake.translateCannabinoidMutex.RUnlock()
	argsForCall := fake.translateCannabinoidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateCannabinoidReturns(result1 *models.Cannabinoid) {
	fake.translateCannabinoidMutex.Lock()
	defer fake.translateCannabinoidMutex.Unlock()
	fake.TranslateCannabinoidStub = nil
	fake.translateCannabinoidReturns = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCannabinoidReturnsOnCall(i int, result1 *models.Cannabinoid) {
	fake.translateCannabinoidMutex.Lock()
	defer fake.translateCannabinoidMutex.Unlock()
	fake.TranslateCannabinoidStub = nil
	if fake.translateCannabinoidReturnsOnCall == nil {
		fake.translateCannabinoidReturnsOnCall = make(map[int]struct {
			result1 *models.Cannabinoid
		})
	}
	fake.translateCannabinoidReturnsOnCall[i] = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCannabinoids(arg1 []*modelsa.Cannabinoid) []*models.Cannabinoid {
	var arg1Copy []*modelsa.Cannabinoid
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Cannabinoid, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateCannabinoidsMutex.Lock()
	ret, specificReturn := fake.translateCannabinoidsReturnsOnCall[len(fake.translateCannabinoidsArgsForCall)]
	fake.translateCannabinoidsArgsForCall = append(fake.translateCannabinoidsArgsForCall, struct {
		arg1 []*modelsa.Cannabinoid
	}{arg1Copy})
	stub := fake.TranslateCannabinoidsStub
	fakeReturns := fake.translateCannabinoidsReturns
	fake.recordInvocation("TranslateCannabinoids", []interface{}{arg1Copy})
	fake.translateCannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateCannabinoidsCallCount() int {
	fake.translateCannabinoidsMutex.RLock()
	defer fake.translateCannabinoidsMutex.RUnlock()
	return len(fake.translateCannabinoidsArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateCannabinoidsCalls(stub func([]*modelsa.Cannabinoid) []*models.Cannabinoid) {
	fake.translateCannabinoidsMutex.Lock()
	defer fake.translateCannabinoidsMutex.Unlock()
	fake.TranslateCannabinoidsStub = stub
}

func (fake *FakeAPITranslatable) TranslateCannabinoidsArgsForCall(i int) []*modelsa.Cannabinoid {
	fake.translateCannabinoidsMutex.RLock()
	defer fake.translateCannabinoidsMutex.RUnlock()
	argsForCall := fake.translateCannabinoidsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateCannabinoidsReturns(result1 []*models.Cannabinoid) {
	fake.translateCannabinoidsMutex.Lock()
	defer fake.translateCannabinoidsMutex.Unlock()
	fake.TranslateCannabinoidsStub = nil
	fake.translateCannabinoidsReturns = struct {
		result1 []*models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCannabinoidsReturnsOnCall(i int, result1 []*models.Cannabinoid) {
	fake.translateCannabinoidsMutex.Lock()
	defer fake.translateCannabinoidsMutex.Unlock()
	fake.TranslateCannabinoidsStub = nil
	if fake.translateCannabinoidsReturnsOnCall == nil {
		fake.translateCannabinoidsReturnsOnCall = make(map[int]struct {
			result1 []*models.Cannabinoid
		})
	}
	fake.translateCannabinoidsReturnsOnCall[i] = struct {
		result1 []*models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCategories(arg1 []string) []string {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateCategoriesMutex.Lock()
	ret, specificReturn := fake.translateCategoriesReturnsOnCall[len(fake.translateCategoriesArgsForCall)]
	fake.translateCategoriesArgsForCall = append(fake.translateCategoriesArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.TranslateCategoriesStub
	fakeReturns := fake.translateCategoriesReturns
	fake.recordInvocation("TranslateCategories", []interface{}{arg1Copy})
	fake.translateCategoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateCategoriesCallCount() int {
	fake.translateCategoriesMutex.RLock()
	defer fake.translateCategoriesMutex.RUnlock()
	return len(fake.translateCategoriesArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateCategoriesCalls(stub func([]string) []string) {
	fake.translateCategoriesMutex.Lock()
	defer fake.translateCategoriesMutex.Unlock()
	fake.TranslateCategoriesStub = stub
}

func (fake *FakeAPITranslatable) TranslateCategoriesArgsForCall(i int) []string {
	fake.translateCategoriesMutex.RLock()
	defer fake.translateCategoriesMutex.RUnlock()
	argsForCall := fake.translateCategoriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateCategoriesReturns(result1 []string) {
	fake.translateCategoriesMutex.Lock()
	defer fake.translateCategoriesMutex.Unlock()
	fake.TranslateCategoriesStub = nil
	fake.translateCategoriesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCategoriesReturnsOnCall(i int, result1 []string) {
	fake.translateCategoriesMutex.Lock()
	defer fake.translateCategoriesMutex.Unlock()
	fake.TranslateCategoriesStub = nil
	if fake.translateCategoriesReturnsOnCall == nil {
		fake.translateCategoriesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.translateCategoriesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCategory(arg1 string) string {
	fake.translateCategoryMutex.Lock()
	ret, specificReturn := fake.translateCategoryReturnsOnCall[len(fake.translateCategoryArgsForCall)]
	fake.translateCategoryArgsForCall = append(fake.translateCategoryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TranslateCategoryStub
	fakeReturns := fake.translateCategoryReturns
	fake.recordInvocation("TranslateCategory", []interface{}{arg1})
	fake.translateCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateCategoryCallCount() int {
	fake.translateCategoryMutex.RLock()
	defer fake.translateCategoryMutex.RUnlock()
	return len(fake.translateCategoryArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateCategoryCalls(stub func(string) string) {
	fake.translateCategoryMutex.Lock()
	defer fake.translateCategoryMutex.Unlock()
	fake.TranslateCategoryStub = stub
}

func (fake *FakeAPITranslatable) TranslateCategoryArgsForCall(i int) string {
	fake.translateCategoryMutex.RLock()
	defer fake.translateCategoryMutex.RUnlock()
	argsForCall := fake.translateCategoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateCategoryReturns(result1 string) {
	fake.translateCategoryMutex.Lock()
	defer fake.translateCategoryMutex.Unlock()
	fake.TranslateCategoryStub = nil
	fake.translateCategoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateCategoryReturnsOnCall(i int, result1 string) {
	fake.translateCategoryMutex.Lock()
	defer fake.translateCategoryMutex.Unlock()
	fake.TranslateCategoryStub = nil
	if fake.translateCategoryReturnsOnCall == nil {
		fake.translateCategoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.translateCategoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateDispensaries(arg1 []*modelsa.Dispensary) []*models.Dispensary {
	var arg1Copy []*modelsa.Dispensary
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Dispensary, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateDispensariesMutex.Lock()
	ret, specificReturn := fake.translateDispensariesReturnsOnCall[len(fake.translateDispensariesArgsForCall)]
	fake.translateDispensariesArgsForCall = append(fake.translateDispensariesArgsForCall, struct {
		arg1 []*modelsa.Dispensary
	}{arg1Copy})
	stub := fake.TranslateDispensariesStub
	fakeReturns := fake.translateDispensariesReturns
	fake.recordInvocation("TranslateDispensaries", []interface{}{arg1Copy})
	fake.translateDispensariesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateDispensariesCallCount() int {
	fake.translateDispensariesMutex.RLock()
	defer fake.translateDispensariesMutex.RUnlock()
	return len(fake.translateDispensariesArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateDispensariesCalls(stub func([]*modelsa.Dispensary) []*models.Dispensary) {
	fake.translateDispensariesMutex.Lock()
	defer fake.translateDispensariesMutex.Unlock()
	fake.TranslateDispensariesStub = stub
}

func (fake *FakeAPITranslatable) TranslateDispensariesArgsForCall(i int) []*modelsa.Dispensary {
	fake.translateDispensariesMutex.RLock()
	defer fake.translateDispensariesMutex.RUnlock()
	argsForCall := fake.translateDispensariesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateDispensariesReturns(result1 []*models.Dispensary) {
	fake.translateDispensariesMutex.Lock()
	defer fake.translateDispensariesMutex.Unlock()
	fake.TranslateDispensariesStub = nil
	fake.translateDispensariesReturns = struct {
		result1 []*models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateDispensariesReturnsOnCall(i int, result1 []*models.Dispensary) {
	fake.translateDispensariesMutex.Lock()
	defer fake.translateDispensariesMutex.Unlock()
	fake.TranslateDispensariesStub = nil
	if fake.translateDispensariesReturnsOnCall == nil {
		fake.translateDispensariesReturnsOnCall = make(map[int]struct {
			result1 []*models.Dispensary
		})
	}
	fake.translateDispensariesReturnsOnCall[i] = struct {
		result1 []*models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateDispensary(arg1 *modelsa.Dispensary) *models.Dispensary {
	fake.translateDispensaryMutex.Lock()
	ret, specificReturn := fake.translateDispensaryReturnsOnCall[len(fake.translateDispensaryArgsForCall)]
	fake.translateDispensaryArgsForCall = append(fake.translateDispensaryArgsForCall, struct {
		arg1 *modelsa.Dispensary
	}{arg1})
	stub := fake.TranslateDispensaryStub
	fakeReturns := fake.translateDispensaryReturns
	fake.recordInvocation("TranslateDispensary", []interface{}{arg1})
	fake.translateDispensaryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateDispensaryCallCount() int {
	fake.translateDispensaryMutex.RLock()
	defer fake.translateDispensaryMutex.RUnlock()
	return len(fake.translateDispensaryArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateDispensaryCalls(stub func(*modelsa.Dispensary) *models.Dispensary) {
	fake.translateDispensaryMutex.Lock()
	defer fake.translateDispensaryMutex.Unlock()
	fake.TranslateDispensaryStub = stub
}

func (fake *FakeAPITranslatable) TranslateDispensaryArgsForCall(i int) *modelsa.Dispensary {
	fake.translateDispensaryMutex.RLock()
	defer fake.translateDispensaryMutex.RUnlock()
	argsForCall := fake.translateDispensaryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateDispensaryReturns(result1 *models.Dispensary) {
	fake.translateDispensaryMutex.Lock()
	defer fake.translateDispensaryMutex.Unlock()
	fake.TranslateDispensaryStub = nil
	fake.translateDispensaryReturns = struct {
		result1 *models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateDispensaryReturnsOnCall(i int, result1 *models.Dispensary) {
	fake.translateDispensaryMutex.Lock()
	defer fake.translateDispensaryMutex.Unlock()
	fake.TranslateDispensaryStub = nil
	if fake.translateDispensaryReturnsOnCall == nil {
		fake.translateDispensaryReturnsOnCall = make(map[int]struct {
			result1 *models.Dispensary
		})
	}
	fake.translateDispensaryReturnsOnCall[i] = struct {
		result1 *models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateLocation(arg1 *modelsa.Location) *models.Location {
	fake.translateLocationMutex.Lock()
	ret, specificReturn := fake.translateLocationReturnsOnCall[len(fake.translateLocationArgsForCall)]
	fake.translateLocationArgsForCall = append(fake.translateLocationArgsForCall, struct {
		arg1 *modelsa.Location
	}{arg1})
	stub := fake.TranslateLocationStub
	fakeReturns := fake.translateLocationReturns
	fake.recordInvocation("TranslateLocation", []interface{}{arg1})
	fake.translateLocationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateLocationCallCount() int {
	fake.translateLocationMutex.RLock()
	defer fake.translateLocationMutex.RUnlock()
	return len(fake.translateLocationArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateLocationCalls(stub func(*modelsa.Location) *models.Location) {
	fake.translateLocationMutex.Lock()
	defer fake.translateLocationMutex.Unlock()
	fake.TranslateLocationStub = stub
}

func (fake *FakeAPITranslatable) TranslateLocationArgsForCall(i int) *modelsa.Location {
	fake.translateLocationMutex.RLock()
	defer fake.translateLocationMutex.RUnlock()
	argsForCall := fake.translateLocationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateLocationReturns(result1 *models.Location) {
	fake.translateLocationMutex.Lock()
	defer fake.translateLocationMutex.Unlock()
	fake.TranslateLocationStub = nil
	fake.translateLocationReturns = struct {
		result1 *models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateLocationReturnsOnCall(i int, result1 *models.Location) {
	fake.translateLocationMutex.Lock()
	defer fake.translateLocationMutex.Unlock()
	fake.TranslateLocationStub = nil
	if fake.translateLocationReturnsOnCall == nil {
		fake.translateLocationReturnsOnCall = make(map[int]struct {
			result1 *models.Location
		})
	}
	fake.translateLocationReturnsOnCall[i] = struct {
		result1 *models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateLocations(arg1 []*modelsa.Location) []*models.Location {
	var arg1Copy []*modelsa.Location
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Location, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateLocationsMutex.Lock()
	ret, specificReturn := fake.translateLocationsReturnsOnCall[len(fake.translateLocationsArgsForCall)]
	fake.translateLocationsArgsForCall = append(fake.translateLocationsArgsForCall, struct {
		arg1 []*modelsa.Location
	}{arg1Copy})
	stub := fake.TranslateLocationsStub
	fakeReturns := fake.translateLocationsReturns
	fake.recordInvocation("TranslateLocations", []interface{}{arg1Copy})
	fake.translateLocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateLocationsCallCount() int {
	fake.translateLocationsMutex.RLock()
	defer fake.translateLocationsMutex.RUnlock()
	return len(fake.translateLocationsArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateLocationsCalls(stub func([]*modelsa.Location) []*models.Location) {
	fake.translateLocationsMutex.Lock()
	defer fake.translateLocationsMutex.Unlock()
	fake.TranslateLocationsStub = stub
}

func (fake *FakeAPITranslatable) TranslateLocationsArgsForCall(i int) []*modelsa.Location {
	fake.translateLocationsMutex.RLock()
	defer fake.translateLocationsMutex.RUnlock()
	argsForCall := fake.translateLocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateLocationsReturns(result1 []*models.Location) {
	fake.translateLocationsMutex.Lock()
	defer fake.translateLocationsMutex.Unlock()
	fake.TranslateLocationsStub = nil
	fake.translateLocationsReturns = struct {
		result1 []*models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateLocationsReturnsOnCall(i int, result1 []*models.Location) {
	fake.translateLocationsMutex.Lock()
	defer fake.translateLocationsMutex.Unlock()
	fake.TranslateLocationsStub = nil
	if fake.translateLocationsReturnsOnCall == nil {
		fake.translateLocationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Location
		})
	}
	fake.translateLocationsReturnsOnCall[i] = struct {
		result1 []*models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateOffer(arg1 *modelsa.Offer) *models.Offer {
	fake.translateOfferMutex.Lock()
	ret, specificReturn := fake.translateOfferReturnsOnCall[len(fake.translateOfferArgsForCall)]
	fake.translateOfferArgsForCall = append(fake.translateOfferArgsForCall, struct {
		arg1 *modelsa.Offer
	}{arg1})
	stub := fake.TranslateOfferStub
	fakeReturns := fake.translateOfferReturns
	fake.recordInvocation("TranslateOffer", []interface{}{arg1})
	fake.translateOfferMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateOfferCallCount() int {
	fake.translateOfferMutex.RLock()
	defer fake.translateOfferMutex.RUnlock()
	return len(fake.translateOfferArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateOfferCalls(stub func(*modelsa.Offer) *models.Offer) {
	fake.translateOfferMutex.Lock()
	defer fake.translateOfferMutex.Unlock()
	fake.TranslateOfferStub = stub
}

func (fake *FakeAPITranslatable) TranslateOfferArgsForCall(i int) *modelsa.Offer {
	fake.translateOfferMutex.RLock()
	defer fake.translateOfferMutex.RUnlock()
	argsForCall := fake.translateOfferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateOfferReturns(result1 *models.Offer) {
	fake.translateOfferMutex.Lock()
	defer fake.translateOfferMutex.Unlock()
	fake.TranslateOfferStub = nil
	fake.translateOfferReturns = struct {
		result1 *models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateOfferReturnsOnCall(i int, result1 *models.Offer) {
	fake.translateOfferMutex.Lock()
	defer fake.translateOfferMutex.Unlock()
	fake.TranslateOfferStub = nil
	if fake.translateOfferReturnsOnCall == nil {
		fake.translateOfferReturnsOnCall = make(map[int]struct {
			result1 *models.Offer
		})
	}
	fake.translateOfferReturnsOnCall[i] = struct {
		result1 *models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateOffers(arg1 []*modelsa.Offer) []*models.Offer {
	var arg1Copy []*modelsa.Offer
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Offer, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateOffersMutex.Lock()
	ret, specificReturn := fake.translateOffersReturnsOnCall[len(fake.translateOffersArgsForCall)]
	fake.translateOffersArgsForCall = append(fake.translateOffersArgsForCall, struct {
		arg1 []*modelsa.Offer
	}{arg1Copy})
	stub := fake.TranslateOffersStub
	fakeReturns := fake.translateOffersReturns
	fake.recordInvocation("TranslateOffers", []interface{}{arg1Copy})
	fake.translateOffersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateOffersCallCount() int {
	fake.translateOffersMutex.RLock()
	defer fake.translateOffersMutex.RUnlock()
	return len(fake.translateOffersArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateOffersCalls(stub func([]*modelsa.Offer) []*models.Offer) {
	fake.translateOffersMutex.Lock()
	defer fake.translateOffersMutex.Unlock()
	fake.TranslateOffersStub = stub
}

func (fake *FakeAPITranslatable) TranslateOffersArgsForCall(i int) []*modelsa.Offer {
	fake.translateOffersMutex.RLock()
	defer fake.translateOffersMutex.RUnlock()
	argsForCall := fake.translateOffersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateOffersReturns(result1 []*models.Offer) {
	fake.translateOffersMutex.Lock()
	defer fake.translateOffersMutex.Unlock()
	fake.TranslateOffersStub = nil
	fake.translateOffersReturns = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateOffersReturnsOnCall(i int, result1 []*models.Offer) {
	fake.translateOffersMutex.Lock()
	defer fake.translateOffersMutex.Unlock()
	fake.TranslateOffersStub = nil
	if fake.translateOffersReturnsOnCall == nil {
		fake.translateOffersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
		})
	}
	fake.translateOffersReturnsOnCall[i] = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateProduct(arg1 *modelsa.Product) *models.Product {
	fake.translateProductMutex.Lock()
	ret, specificReturn := fake.translateProductReturnsOnCall[len(fake.translateProductArgsForCall)]
	fake.translateProductArgsForCall = append(fake.translateProductArgsForCall, struct {
		arg1 *modelsa.Product
	}{arg1})
	stub := fake.TranslateProductStub
	fakeReturns := fake.translateProductReturns
	fake.recordInvocation("TranslateProduct", []interface{}{arg1})
	fake.translateProductMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateProductCallCount() int {
	fake.translateProductMutex.RLock()
	defer fake.translateProductMutex.RUnlock()
	return len(fake.translateProductArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateProductCalls(stub func(*modelsa.Product) *models.Product) {
	fake.translateProductMutex.Lock()
	defer fake.translateProductMutex.Unlock()
	fake.TranslateProductStub = stub
}

func (fake *FakeAPITranslatable) TranslateProductArgsForCall(i int) *modelsa.Product {
	fake.translateProductMutex.RLock()
	defer fake.translateProductMutex.RUnlock()
	argsForCall := fake.translateProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateProductReturns(result1 *models.Product) {
	fake.translateProductMutex.Lock()
	defer fake.translateProductMutex.Unlock()
	fake.TranslateProductStub = nil
	fake.translateProductReturns = struct {
		result1 *models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateProductReturnsOnCall(i int, result1 *models.Product) {
	fake.translateProductMutex.Lock()
	defer fake.translateProductMutex.Unlock()
	fake.TranslateProductStub = nil
	if fake.translateProductReturnsOnCall == nil {
		fake.translateProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
		})
	}
	fake.translateProductReturnsOnCall[i] = struct {
		result1 *models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateProducts(arg1 []*modelsa.Product) []*models.Product {
	var arg1Copy []*modelsa.Product
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Product, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateProductsMutex.Lock()
	ret, specificReturn := fake.translateProductsReturnsOnCall[len(fake.translateProductsArgsForCall)]
	fake.translateProductsArgsForCall = append(fake.translateProductsArgsForCall, struct {
		arg1 []*modelsa.Product
	}{arg1Copy})
	stub := fake.TranslateProductsStub
	fakeReturns := fake.translateProductsReturns
	fake.recordInvocation("TranslateProducts", []interface{}{arg1Copy})
	fake.translateProductsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateProductsCallCount() int {
	fake.translateProductsMutex.RLock()
	defer fake.translateProductsMutex.RUnlock()
	return len(fake.translateProductsArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateProductsCalls(stub func([]*modelsa.Product) []*models.Product) {
	fake.translateProductsMutex.Lock()
	defer fake.translateProductsMutex.Unlock()
	fake.TranslateProductsStub = stub
}

func (fake *FakeAPITranslatable) TranslateProductsArgsForCall(i int) []*modelsa.Product {
	fake.translateProductsMutex.RLock()
	defer fake.translateProductsMutex.RUnlock()
	argsForCall := fake.translateProductsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateProductsReturns(result1 []*models.Product) {
	fake.translateProductsMutex.Lock()
	defer fake.translateProductsMutex.Unlock()
	fake.TranslateProductsStub = nil
	fake.translateProductsReturns = struct {
		result1 []*models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateProductsReturnsOnCall(i int, result1 []*models.Product) {
	fake.translateProductsMutex.Lock()
	defer fake.translateProductsMutex.Unlock()
	fake.TranslateProductsStub = nil
	if fake.translateProductsReturnsOnCall == nil {
		fake.translateProductsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
		})
	}
	fake.translateProductsReturnsOnCall[i] = struct {
		result1 []*models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateTerpene(arg1 *modelsa.Terpene) *models.Terpene {
	fake.translateTerpeneMutex.Lock()
	ret, specificReturn := fake.translateTerpeneReturnsOnCall[len(fake.translateTerpeneArgsForCall)]
	fake.translateTerpeneArgsForCall = append(fake.translateTerpeneArgsForCall, struct {
		arg1 *modelsa.Terpene
	}{arg1})
	stub := fake.TranslateTerpeneStub
	fakeReturns := fake.translateTerpeneReturns
	fake.recordInvocation("TranslateTerpene", []interface{}{arg1})
	fake.translateTerpeneMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateTerpeneCallCount() int {
	fake.translateTerpeneMutex.RLock()
	defer fake.translateTerpeneMutex.RUnlock()
	return len(fake.translateTerpeneArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateTerpeneCalls(stub func(*modelsa.Terpene) *models.Terpene) {
	fake.translateTerpeneMutex.Lock()
	defer fake.translateTerpeneMutex.Unlock()
	fake.TranslateTerpeneStub = stub
}

func (fake *FakeAPITranslatable) TranslateTerpeneArgsForCall(i int) *modelsa.Terpene {
	fake.translateTerpeneMutex.RLock()
	defer fake.translateTerpeneMutex.RUnlock()
	argsForCall := fake.translateTerpeneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateTerpeneReturns(result1 *models.Terpene) {
	fake.translateTerpeneMutex.Lock()
	defer fake.translateTerpeneMutex.Unlock()
	fake.TranslateTerpeneStub = nil
	fake.translateTerpeneReturns = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateTerpeneReturnsOnCall(i int, result1 *models.Terpene) {
	fake.translateTerpeneMutex.Lock()
	defer fake.translateTerpeneMutex.Unlock()
	fake.TranslateTerpeneStub = nil
	if fake.translateTerpeneReturnsOnCall == nil {
		fake.translateTerpeneReturnsOnCall = make(map[int]struct {
			result1 *models.Terpene
		})
	}
	fake.translateTerpeneReturnsOnCall[i] = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateTerpenes(arg1 []*modelsa.Terpene) []*models.Terpene {
	var arg1Copy []*modelsa.Terpene
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Terpene, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateTerpenesMutex.Lock()
	ret, specificReturn := fake.translateTerpenesReturnsOnCall[len(fake.translateTerpenesArgsForCall)]
	fake.translateTerpenesArgsForCall = append(fake.translateTerpenesArgsForCall, struct {
		arg1 []*modelsa.Terpene
	}{arg1Copy})
	stub := fake.TranslateTerpenesStub
	fakeReturns := fake.translateTerpenesReturns
	fake.recordInvocation("TranslateTerpenes", []interface{}{arg1Copy})
	fake.translateTerpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateTerpenesCallCount() int {
	fake.translateTerpenesMutex.RLock()
	defer fake.translateTerpenesMutex.RUnlock()
	return len(fake.translateTerpenesArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateTerpenesCalls(stub func([]*modelsa.Terpene) []*models.Terpene) {
	fake.translateTerpenesMutex.Lock()
	defer fake.translateTerpenesMutex.Unlock()
	fake.TranslateTerpenesStub = stub
}

func (fake *FakeAPITranslatable) TranslateTerpenesArgsForCall(i int) []*modelsa.Terpene {
	fake.translateTerpenesMutex.RLock()
	defer fake.translateTerpenesMutex.RUnlock()
	argsForCall := fake.translateTerpenesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateTerpenesReturns(result1 []*models.Terpene) {
	fake.translateTerpenesMutex.Lock()
	defer fake.translateTerpenesMutex.Unlock()
	fake.TranslateTerpenesStub = nil
	fake.translateTerpenesReturns = struct {
		result1 []*models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateTerpenesReturnsOnCall(i int, result1 []*models.Terpene) {
	fake.translateTerpenesMutex.Lock()
	defer fake.translateTerpenesMutex.Unlock()
	fake.TranslateTerpenesStub = nil
	if fake.translateTerpenesReturnsOnCall == nil {
		fake.translateTerpenesReturnsOnCall = make(map[int]struct {
			result1 []*models.Terpene
		})
	}
	fake.translateTerpenesReturnsOnCall[i] = struct {
		result1 []*models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.translateCannabinoidMutex.RLock()
	defer fake.translateCannabinoidMutex.RUnlock()
	fake.translateCannabinoidsMutex.RLock()
	defer fake.translateCannabinoidsMutex.RUnlock()
	fake.translateCategoriesMutex.RLock()
	defer fake.translateCategoriesMutex.RUnlock()
	fake.translateCategoryMutex.RLock()
	defer fake.translateCategoryMutex.RUnlock()
	fake.translateDispensariesMutex.RLock()
	defer fake.translateDispensariesMutex.RUnlock()
	fake.translateDispensaryMutex.RLock()
	defer fake.translateDispensaryMutex.RUnlock()
	fake.translateLocationMutex.RLock()
	defer fake.translateLocationMutex.RUnlock()
	fake.translateLocationsMutex.RLock()
	defer fake.translateLocationsMutex.RUnlock()
	fake.translateOfferMutex.RLock()
	defer fake.translateOfferMutex.RUnlock()
	fake.translateOffersMutex.RLock()
	defer fake.translateOffersMutex.RUnlock()
	fake.translateProductMutex.RLock()
	defer fake.translateProductMutex.RUnlock()
	fake.translateProductsMutex.RLock()
	defer fake.translateProductsMutex.RUnlock()
	fake.translateTerpeneMutex.RLock()
	defer fake.translateTerpeneMutex.RUnlock()
	fake.translateTerpenesMutex.RLock()
	defer fake.translateTerpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAPITranslatable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ translation.APITranslatable = new(FakeAPITranslatable)
