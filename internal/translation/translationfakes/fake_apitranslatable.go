// Code generated by counterfeiter. DO NOT EDIT.
package translationfakes

import (
	"sync"

	"github.com/Linkinlog/LeafListr/internal/api/models"
	modelsa "github.com/Linkinlog/LeafListr/internal/models"
	"github.com/Linkinlog/LeafListr/internal/translation"
)

type FakeAPITranslatable struct {
	TranslateAPICannabinoidStub        func(*modelsa.Cannabinoid) *models.Cannabinoid
	translateAPICannabinoidMutex       sync.RWMutex
	translateAPICannabinoidArgsForCall []struct {
		arg1 *modelsa.Cannabinoid
	}
	translateAPICannabinoidReturns struct {
		result1 *models.Cannabinoid
	}
	translateAPICannabinoidReturnsOnCall map[int]struct {
		result1 *models.Cannabinoid
	}
	TranslateAPICannabinoidsStub        func([]*modelsa.Cannabinoid) []*models.Cannabinoid
	translateAPICannabinoidsMutex       sync.RWMutex
	translateAPICannabinoidsArgsForCall []struct {
		arg1 []*modelsa.Cannabinoid
	}
	translateAPICannabinoidsReturns struct {
		result1 []*models.Cannabinoid
	}
	translateAPICannabinoidsReturnsOnCall map[int]struct {
		result1 []*models.Cannabinoid
	}
	TranslateAPICategoriesStub        func([]*modelsa.Category) []*models.Category
	translateAPICategoriesMutex       sync.RWMutex
	translateAPICategoriesArgsForCall []struct {
		arg1 []*modelsa.Category
	}
	translateAPICategoriesReturns struct {
		result1 []*models.Category
	}
	translateAPICategoriesReturnsOnCall map[int]struct {
		result1 []*models.Category
	}
	TranslateAPICategoryStub        func(*modelsa.Category) *models.Category
	translateAPICategoryMutex       sync.RWMutex
	translateAPICategoryArgsForCall []struct {
		arg1 *modelsa.Category
	}
	translateAPICategoryReturns struct {
		result1 *models.Category
	}
	translateAPICategoryReturnsOnCall map[int]struct {
		result1 *models.Category
	}
	TranslateAPIDispensariesStub        func([]*modelsa.Dispensary) []*models.Dispensary
	translateAPIDispensariesMutex       sync.RWMutex
	translateAPIDispensariesArgsForCall []struct {
		arg1 []*modelsa.Dispensary
	}
	translateAPIDispensariesReturns struct {
		result1 []*models.Dispensary
	}
	translateAPIDispensariesReturnsOnCall map[int]struct {
		result1 []*models.Dispensary
	}
	TranslateAPIDispensaryStub        func(*modelsa.Dispensary) *models.Dispensary
	translateAPIDispensaryMutex       sync.RWMutex
	translateAPIDispensaryArgsForCall []struct {
		arg1 *modelsa.Dispensary
	}
	translateAPIDispensaryReturns struct {
		result1 *models.Dispensary
	}
	translateAPIDispensaryReturnsOnCall map[int]struct {
		result1 *models.Dispensary
	}
	TranslateAPILocationStub        func(*modelsa.Location) *models.Location
	translateAPILocationMutex       sync.RWMutex
	translateAPILocationArgsForCall []struct {
		arg1 *modelsa.Location
	}
	translateAPILocationReturns struct {
		result1 *models.Location
	}
	translateAPILocationReturnsOnCall map[int]struct {
		result1 *models.Location
	}
	TranslateAPILocationsStub        func([]*modelsa.Location) []*models.Location
	translateAPILocationsMutex       sync.RWMutex
	translateAPILocationsArgsForCall []struct {
		arg1 []*modelsa.Location
	}
	translateAPILocationsReturns struct {
		result1 []*models.Location
	}
	translateAPILocationsReturnsOnCall map[int]struct {
		result1 []*models.Location
	}
	TranslateAPIOfferStub        func(*modelsa.Offer) *models.Offer
	translateAPIOfferMutex       sync.RWMutex
	translateAPIOfferArgsForCall []struct {
		arg1 *modelsa.Offer
	}
	translateAPIOfferReturns struct {
		result1 *models.Offer
	}
	translateAPIOfferReturnsOnCall map[int]struct {
		result1 *models.Offer
	}
	TranslateAPIOffersStub        func([]*modelsa.Offer) []*models.Offer
	translateAPIOffersMutex       sync.RWMutex
	translateAPIOffersArgsForCall []struct {
		arg1 []*modelsa.Offer
	}
	translateAPIOffersReturns struct {
		result1 []*models.Offer
	}
	translateAPIOffersReturnsOnCall map[int]struct {
		result1 []*models.Offer
	}
	TranslateAPIProductStub        func(*modelsa.Product) *models.Product
	translateAPIProductMutex       sync.RWMutex
	translateAPIProductArgsForCall []struct {
		arg1 *modelsa.Product
	}
	translateAPIProductReturns struct {
		result1 *models.Product
	}
	translateAPIProductReturnsOnCall map[int]struct {
		result1 *models.Product
	}
	TranslateAPIProductsStub        func([]*modelsa.Product) []*models.Product
	translateAPIProductsMutex       sync.RWMutex
	translateAPIProductsArgsForCall []struct {
		arg1 []*modelsa.Product
	}
	translateAPIProductsReturns struct {
		result1 []*models.Product
	}
	translateAPIProductsReturnsOnCall map[int]struct {
		result1 []*models.Product
	}
	TranslateAPITerpeneStub        func(*modelsa.Terpene) *models.Terpene
	translateAPITerpeneMutex       sync.RWMutex
	translateAPITerpeneArgsForCall []struct {
		arg1 *modelsa.Terpene
	}
	translateAPITerpeneReturns struct {
		result1 *models.Terpene
	}
	translateAPITerpeneReturnsOnCall map[int]struct {
		result1 *models.Terpene
	}
	TranslateAPITerpenesStub        func([]*modelsa.Terpene) []*models.Terpene
	translateAPITerpenesMutex       sync.RWMutex
	translateAPITerpenesArgsForCall []struct {
		arg1 []*modelsa.Terpene
	}
	translateAPITerpenesReturns struct {
		result1 []*models.Terpene
	}
	translateAPITerpenesReturnsOnCall map[int]struct {
		result1 []*models.Terpene
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoid(arg1 *modelsa.Cannabinoid) *models.Cannabinoid {
	fake.translateAPICannabinoidMutex.Lock()
	ret, specificReturn := fake.translateAPICannabinoidReturnsOnCall[len(fake.translateAPICannabinoidArgsForCall)]
	fake.translateAPICannabinoidArgsForCall = append(fake.translateAPICannabinoidArgsForCall, struct {
		arg1 *modelsa.Cannabinoid
	}{arg1})
	stub := fake.TranslateAPICannabinoidStub
	fakeReturns := fake.translateAPICannabinoidReturns
	fake.recordInvocation("TranslateAPICannabinoid", []interface{}{arg1})
	fake.translateAPICannabinoidMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidCallCount() int {
	fake.translateAPICannabinoidMutex.RLock()
	defer fake.translateAPICannabinoidMutex.RUnlock()
	return len(fake.translateAPICannabinoidArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidCalls(stub func(*modelsa.Cannabinoid) *models.Cannabinoid) {
	fake.translateAPICannabinoidMutex.Lock()
	defer fake.translateAPICannabinoidMutex.Unlock()
	fake.TranslateAPICannabinoidStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidArgsForCall(i int) *modelsa.Cannabinoid {
	fake.translateAPICannabinoidMutex.RLock()
	defer fake.translateAPICannabinoidMutex.RUnlock()
	argsForCall := fake.translateAPICannabinoidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidReturns(result1 *models.Cannabinoid) {
	fake.translateAPICannabinoidMutex.Lock()
	defer fake.translateAPICannabinoidMutex.Unlock()
	fake.TranslateAPICannabinoidStub = nil
	fake.translateAPICannabinoidReturns = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidReturnsOnCall(i int, result1 *models.Cannabinoid) {
	fake.translateAPICannabinoidMutex.Lock()
	defer fake.translateAPICannabinoidMutex.Unlock()
	fake.TranslateAPICannabinoidStub = nil
	if fake.translateAPICannabinoidReturnsOnCall == nil {
		fake.translateAPICannabinoidReturnsOnCall = make(map[int]struct {
			result1 *models.Cannabinoid
		})
	}
	fake.translateAPICannabinoidReturnsOnCall[i] = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoids(arg1 []*modelsa.Cannabinoid) []*models.Cannabinoid {
	var arg1Copy []*modelsa.Cannabinoid
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Cannabinoid, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPICannabinoidsMutex.Lock()
	ret, specificReturn := fake.translateAPICannabinoidsReturnsOnCall[len(fake.translateAPICannabinoidsArgsForCall)]
	fake.translateAPICannabinoidsArgsForCall = append(fake.translateAPICannabinoidsArgsForCall, struct {
		arg1 []*modelsa.Cannabinoid
	}{arg1Copy})
	stub := fake.TranslateAPICannabinoidsStub
	fakeReturns := fake.translateAPICannabinoidsReturns
	fake.recordInvocation("TranslateAPICannabinoids", []interface{}{arg1Copy})
	fake.translateAPICannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidsCallCount() int {
	fake.translateAPICannabinoidsMutex.RLock()
	defer fake.translateAPICannabinoidsMutex.RUnlock()
	return len(fake.translateAPICannabinoidsArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidsCalls(stub func([]*modelsa.Cannabinoid) []*models.Cannabinoid) {
	fake.translateAPICannabinoidsMutex.Lock()
	defer fake.translateAPICannabinoidsMutex.Unlock()
	fake.TranslateAPICannabinoidsStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidsArgsForCall(i int) []*modelsa.Cannabinoid {
	fake.translateAPICannabinoidsMutex.RLock()
	defer fake.translateAPICannabinoidsMutex.RUnlock()
	argsForCall := fake.translateAPICannabinoidsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidsReturns(result1 []*models.Cannabinoid) {
	fake.translateAPICannabinoidsMutex.Lock()
	defer fake.translateAPICannabinoidsMutex.Unlock()
	fake.TranslateAPICannabinoidsStub = nil
	fake.translateAPICannabinoidsReturns = struct {
		result1 []*models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICannabinoidsReturnsOnCall(i int, result1 []*models.Cannabinoid) {
	fake.translateAPICannabinoidsMutex.Lock()
	defer fake.translateAPICannabinoidsMutex.Unlock()
	fake.TranslateAPICannabinoidsStub = nil
	if fake.translateAPICannabinoidsReturnsOnCall == nil {
		fake.translateAPICannabinoidsReturnsOnCall = make(map[int]struct {
			result1 []*models.Cannabinoid
		})
	}
	fake.translateAPICannabinoidsReturnsOnCall[i] = struct {
		result1 []*models.Cannabinoid
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICategories(arg1 []*modelsa.Category) []*models.Category {
	var arg1Copy []*modelsa.Category
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Category, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPICategoriesMutex.Lock()
	ret, specificReturn := fake.translateAPICategoriesReturnsOnCall[len(fake.translateAPICategoriesArgsForCall)]
	fake.translateAPICategoriesArgsForCall = append(fake.translateAPICategoriesArgsForCall, struct {
		arg1 []*modelsa.Category
	}{arg1Copy})
	stub := fake.TranslateAPICategoriesStub
	fakeReturns := fake.translateAPICategoriesReturns
	fake.recordInvocation("TranslateAPICategories", []interface{}{arg1Copy})
	fake.translateAPICategoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPICategoriesCallCount() int {
	fake.translateAPICategoriesMutex.RLock()
	defer fake.translateAPICategoriesMutex.RUnlock()
	return len(fake.translateAPICategoriesArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPICategoriesCalls(stub func([]*modelsa.Category) []*models.Category) {
	fake.translateAPICategoriesMutex.Lock()
	defer fake.translateAPICategoriesMutex.Unlock()
	fake.TranslateAPICategoriesStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPICategoriesArgsForCall(i int) []*modelsa.Category {
	fake.translateAPICategoriesMutex.RLock()
	defer fake.translateAPICategoriesMutex.RUnlock()
	argsForCall := fake.translateAPICategoriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPICategoriesReturns(result1 []*models.Category) {
	fake.translateAPICategoriesMutex.Lock()
	defer fake.translateAPICategoriesMutex.Unlock()
	fake.TranslateAPICategoriesStub = nil
	fake.translateAPICategoriesReturns = struct {
		result1 []*models.Category
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICategoriesReturnsOnCall(i int, result1 []*models.Category) {
	fake.translateAPICategoriesMutex.Lock()
	defer fake.translateAPICategoriesMutex.Unlock()
	fake.TranslateAPICategoriesStub = nil
	if fake.translateAPICategoriesReturnsOnCall == nil {
		fake.translateAPICategoriesReturnsOnCall = make(map[int]struct {
			result1 []*models.Category
		})
	}
	fake.translateAPICategoriesReturnsOnCall[i] = struct {
		result1 []*models.Category
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICategory(arg1 *modelsa.Category) *models.Category {
	fake.translateAPICategoryMutex.Lock()
	ret, specificReturn := fake.translateAPICategoryReturnsOnCall[len(fake.translateAPICategoryArgsForCall)]
	fake.translateAPICategoryArgsForCall = append(fake.translateAPICategoryArgsForCall, struct {
		arg1 *modelsa.Category
	}{arg1})
	stub := fake.TranslateAPICategoryStub
	fakeReturns := fake.translateAPICategoryReturns
	fake.recordInvocation("TranslateAPICategory", []interface{}{arg1})
	fake.translateAPICategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPICategoryCallCount() int {
	fake.translateAPICategoryMutex.RLock()
	defer fake.translateAPICategoryMutex.RUnlock()
	return len(fake.translateAPICategoryArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPICategoryCalls(stub func(*modelsa.Category) *models.Category) {
	fake.translateAPICategoryMutex.Lock()
	defer fake.translateAPICategoryMutex.Unlock()
	fake.TranslateAPICategoryStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPICategoryArgsForCall(i int) *modelsa.Category {
	fake.translateAPICategoryMutex.RLock()
	defer fake.translateAPICategoryMutex.RUnlock()
	argsForCall := fake.translateAPICategoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPICategoryReturns(result1 *models.Category) {
	fake.translateAPICategoryMutex.Lock()
	defer fake.translateAPICategoryMutex.Unlock()
	fake.TranslateAPICategoryStub = nil
	fake.translateAPICategoryReturns = struct {
		result1 *models.Category
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPICategoryReturnsOnCall(i int, result1 *models.Category) {
	fake.translateAPICategoryMutex.Lock()
	defer fake.translateAPICategoryMutex.Unlock()
	fake.TranslateAPICategoryStub = nil
	if fake.translateAPICategoryReturnsOnCall == nil {
		fake.translateAPICategoryReturnsOnCall = make(map[int]struct {
			result1 *models.Category
		})
	}
	fake.translateAPICategoryReturnsOnCall[i] = struct {
		result1 *models.Category
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIDispensaries(arg1 []*modelsa.Dispensary) []*models.Dispensary {
	var arg1Copy []*modelsa.Dispensary
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Dispensary, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPIDispensariesMutex.Lock()
	ret, specificReturn := fake.translateAPIDispensariesReturnsOnCall[len(fake.translateAPIDispensariesArgsForCall)]
	fake.translateAPIDispensariesArgsForCall = append(fake.translateAPIDispensariesArgsForCall, struct {
		arg1 []*modelsa.Dispensary
	}{arg1Copy})
	stub := fake.TranslateAPIDispensariesStub
	fakeReturns := fake.translateAPIDispensariesReturns
	fake.recordInvocation("TranslateAPIDispensaries", []interface{}{arg1Copy})
	fake.translateAPIDispensariesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPIDispensariesCallCount() int {
	fake.translateAPIDispensariesMutex.RLock()
	defer fake.translateAPIDispensariesMutex.RUnlock()
	return len(fake.translateAPIDispensariesArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPIDispensariesCalls(stub func([]*modelsa.Dispensary) []*models.Dispensary) {
	fake.translateAPIDispensariesMutex.Lock()
	defer fake.translateAPIDispensariesMutex.Unlock()
	fake.TranslateAPIDispensariesStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPIDispensariesArgsForCall(i int) []*modelsa.Dispensary {
	fake.translateAPIDispensariesMutex.RLock()
	defer fake.translateAPIDispensariesMutex.RUnlock()
	argsForCall := fake.translateAPIDispensariesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPIDispensariesReturns(result1 []*models.Dispensary) {
	fake.translateAPIDispensariesMutex.Lock()
	defer fake.translateAPIDispensariesMutex.Unlock()
	fake.TranslateAPIDispensariesStub = nil
	fake.translateAPIDispensariesReturns = struct {
		result1 []*models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIDispensariesReturnsOnCall(i int, result1 []*models.Dispensary) {
	fake.translateAPIDispensariesMutex.Lock()
	defer fake.translateAPIDispensariesMutex.Unlock()
	fake.TranslateAPIDispensariesStub = nil
	if fake.translateAPIDispensariesReturnsOnCall == nil {
		fake.translateAPIDispensariesReturnsOnCall = make(map[int]struct {
			result1 []*models.Dispensary
		})
	}
	fake.translateAPIDispensariesReturnsOnCall[i] = struct {
		result1 []*models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIDispensary(arg1 *modelsa.Dispensary) *models.Dispensary {
	fake.translateAPIDispensaryMutex.Lock()
	ret, specificReturn := fake.translateAPIDispensaryReturnsOnCall[len(fake.translateAPIDispensaryArgsForCall)]
	fake.translateAPIDispensaryArgsForCall = append(fake.translateAPIDispensaryArgsForCall, struct {
		arg1 *modelsa.Dispensary
	}{arg1})
	stub := fake.TranslateAPIDispensaryStub
	fakeReturns := fake.translateAPIDispensaryReturns
	fake.recordInvocation("TranslateAPIDispensary", []interface{}{arg1})
	fake.translateAPIDispensaryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPIDispensaryCallCount() int {
	fake.translateAPIDispensaryMutex.RLock()
	defer fake.translateAPIDispensaryMutex.RUnlock()
	return len(fake.translateAPIDispensaryArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPIDispensaryCalls(stub func(*modelsa.Dispensary) *models.Dispensary) {
	fake.translateAPIDispensaryMutex.Lock()
	defer fake.translateAPIDispensaryMutex.Unlock()
	fake.TranslateAPIDispensaryStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPIDispensaryArgsForCall(i int) *modelsa.Dispensary {
	fake.translateAPIDispensaryMutex.RLock()
	defer fake.translateAPIDispensaryMutex.RUnlock()
	argsForCall := fake.translateAPIDispensaryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPIDispensaryReturns(result1 *models.Dispensary) {
	fake.translateAPIDispensaryMutex.Lock()
	defer fake.translateAPIDispensaryMutex.Unlock()
	fake.TranslateAPIDispensaryStub = nil
	fake.translateAPIDispensaryReturns = struct {
		result1 *models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIDispensaryReturnsOnCall(i int, result1 *models.Dispensary) {
	fake.translateAPIDispensaryMutex.Lock()
	defer fake.translateAPIDispensaryMutex.Unlock()
	fake.TranslateAPIDispensaryStub = nil
	if fake.translateAPIDispensaryReturnsOnCall == nil {
		fake.translateAPIDispensaryReturnsOnCall = make(map[int]struct {
			result1 *models.Dispensary
		})
	}
	fake.translateAPIDispensaryReturnsOnCall[i] = struct {
		result1 *models.Dispensary
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPILocation(arg1 *modelsa.Location) *models.Location {
	fake.translateAPILocationMutex.Lock()
	ret, specificReturn := fake.translateAPILocationReturnsOnCall[len(fake.translateAPILocationArgsForCall)]
	fake.translateAPILocationArgsForCall = append(fake.translateAPILocationArgsForCall, struct {
		arg1 *modelsa.Location
	}{arg1})
	stub := fake.TranslateAPILocationStub
	fakeReturns := fake.translateAPILocationReturns
	fake.recordInvocation("TranslateAPILocation", []interface{}{arg1})
	fake.translateAPILocationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPILocationCallCount() int {
	fake.translateAPILocationMutex.RLock()
	defer fake.translateAPILocationMutex.RUnlock()
	return len(fake.translateAPILocationArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPILocationCalls(stub func(*modelsa.Location) *models.Location) {
	fake.translateAPILocationMutex.Lock()
	defer fake.translateAPILocationMutex.Unlock()
	fake.TranslateAPILocationStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPILocationArgsForCall(i int) *modelsa.Location {
	fake.translateAPILocationMutex.RLock()
	defer fake.translateAPILocationMutex.RUnlock()
	argsForCall := fake.translateAPILocationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPILocationReturns(result1 *models.Location) {
	fake.translateAPILocationMutex.Lock()
	defer fake.translateAPILocationMutex.Unlock()
	fake.TranslateAPILocationStub = nil
	fake.translateAPILocationReturns = struct {
		result1 *models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPILocationReturnsOnCall(i int, result1 *models.Location) {
	fake.translateAPILocationMutex.Lock()
	defer fake.translateAPILocationMutex.Unlock()
	fake.TranslateAPILocationStub = nil
	if fake.translateAPILocationReturnsOnCall == nil {
		fake.translateAPILocationReturnsOnCall = make(map[int]struct {
			result1 *models.Location
		})
	}
	fake.translateAPILocationReturnsOnCall[i] = struct {
		result1 *models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPILocations(arg1 []*modelsa.Location) []*models.Location {
	var arg1Copy []*modelsa.Location
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Location, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPILocationsMutex.Lock()
	ret, specificReturn := fake.translateAPILocationsReturnsOnCall[len(fake.translateAPILocationsArgsForCall)]
	fake.translateAPILocationsArgsForCall = append(fake.translateAPILocationsArgsForCall, struct {
		arg1 []*modelsa.Location
	}{arg1Copy})
	stub := fake.TranslateAPILocationsStub
	fakeReturns := fake.translateAPILocationsReturns
	fake.recordInvocation("TranslateAPILocations", []interface{}{arg1Copy})
	fake.translateAPILocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPILocationsCallCount() int {
	fake.translateAPILocationsMutex.RLock()
	defer fake.translateAPILocationsMutex.RUnlock()
	return len(fake.translateAPILocationsArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPILocationsCalls(stub func([]*modelsa.Location) []*models.Location) {
	fake.translateAPILocationsMutex.Lock()
	defer fake.translateAPILocationsMutex.Unlock()
	fake.TranslateAPILocationsStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPILocationsArgsForCall(i int) []*modelsa.Location {
	fake.translateAPILocationsMutex.RLock()
	defer fake.translateAPILocationsMutex.RUnlock()
	argsForCall := fake.translateAPILocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPILocationsReturns(result1 []*models.Location) {
	fake.translateAPILocationsMutex.Lock()
	defer fake.translateAPILocationsMutex.Unlock()
	fake.TranslateAPILocationsStub = nil
	fake.translateAPILocationsReturns = struct {
		result1 []*models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPILocationsReturnsOnCall(i int, result1 []*models.Location) {
	fake.translateAPILocationsMutex.Lock()
	defer fake.translateAPILocationsMutex.Unlock()
	fake.TranslateAPILocationsStub = nil
	if fake.translateAPILocationsReturnsOnCall == nil {
		fake.translateAPILocationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Location
		})
	}
	fake.translateAPILocationsReturnsOnCall[i] = struct {
		result1 []*models.Location
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIOffer(arg1 *modelsa.Offer) *models.Offer {
	fake.translateAPIOfferMutex.Lock()
	ret, specificReturn := fake.translateAPIOfferReturnsOnCall[len(fake.translateAPIOfferArgsForCall)]
	fake.translateAPIOfferArgsForCall = append(fake.translateAPIOfferArgsForCall, struct {
		arg1 *modelsa.Offer
	}{arg1})
	stub := fake.TranslateAPIOfferStub
	fakeReturns := fake.translateAPIOfferReturns
	fake.recordInvocation("TranslateAPIOffer", []interface{}{arg1})
	fake.translateAPIOfferMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPIOfferCallCount() int {
	fake.translateAPIOfferMutex.RLock()
	defer fake.translateAPIOfferMutex.RUnlock()
	return len(fake.translateAPIOfferArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPIOfferCalls(stub func(*modelsa.Offer) *models.Offer) {
	fake.translateAPIOfferMutex.Lock()
	defer fake.translateAPIOfferMutex.Unlock()
	fake.TranslateAPIOfferStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPIOfferArgsForCall(i int) *modelsa.Offer {
	fake.translateAPIOfferMutex.RLock()
	defer fake.translateAPIOfferMutex.RUnlock()
	argsForCall := fake.translateAPIOfferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPIOfferReturns(result1 *models.Offer) {
	fake.translateAPIOfferMutex.Lock()
	defer fake.translateAPIOfferMutex.Unlock()
	fake.TranslateAPIOfferStub = nil
	fake.translateAPIOfferReturns = struct {
		result1 *models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIOfferReturnsOnCall(i int, result1 *models.Offer) {
	fake.translateAPIOfferMutex.Lock()
	defer fake.translateAPIOfferMutex.Unlock()
	fake.TranslateAPIOfferStub = nil
	if fake.translateAPIOfferReturnsOnCall == nil {
		fake.translateAPIOfferReturnsOnCall = make(map[int]struct {
			result1 *models.Offer
		})
	}
	fake.translateAPIOfferReturnsOnCall[i] = struct {
		result1 *models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIOffers(arg1 []*modelsa.Offer) []*models.Offer {
	var arg1Copy []*modelsa.Offer
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Offer, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPIOffersMutex.Lock()
	ret, specificReturn := fake.translateAPIOffersReturnsOnCall[len(fake.translateAPIOffersArgsForCall)]
	fake.translateAPIOffersArgsForCall = append(fake.translateAPIOffersArgsForCall, struct {
		arg1 []*modelsa.Offer
	}{arg1Copy})
	stub := fake.TranslateAPIOffersStub
	fakeReturns := fake.translateAPIOffersReturns
	fake.recordInvocation("TranslateAPIOffers", []interface{}{arg1Copy})
	fake.translateAPIOffersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPIOffersCallCount() int {
	fake.translateAPIOffersMutex.RLock()
	defer fake.translateAPIOffersMutex.RUnlock()
	return len(fake.translateAPIOffersArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPIOffersCalls(stub func([]*modelsa.Offer) []*models.Offer) {
	fake.translateAPIOffersMutex.Lock()
	defer fake.translateAPIOffersMutex.Unlock()
	fake.TranslateAPIOffersStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPIOffersArgsForCall(i int) []*modelsa.Offer {
	fake.translateAPIOffersMutex.RLock()
	defer fake.translateAPIOffersMutex.RUnlock()
	argsForCall := fake.translateAPIOffersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPIOffersReturns(result1 []*models.Offer) {
	fake.translateAPIOffersMutex.Lock()
	defer fake.translateAPIOffersMutex.Unlock()
	fake.TranslateAPIOffersStub = nil
	fake.translateAPIOffersReturns = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIOffersReturnsOnCall(i int, result1 []*models.Offer) {
	fake.translateAPIOffersMutex.Lock()
	defer fake.translateAPIOffersMutex.Unlock()
	fake.TranslateAPIOffersStub = nil
	if fake.translateAPIOffersReturnsOnCall == nil {
		fake.translateAPIOffersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
		})
	}
	fake.translateAPIOffersReturnsOnCall[i] = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIProduct(arg1 *modelsa.Product) *models.Product {
	fake.translateAPIProductMutex.Lock()
	ret, specificReturn := fake.translateAPIProductReturnsOnCall[len(fake.translateAPIProductArgsForCall)]
	fake.translateAPIProductArgsForCall = append(fake.translateAPIProductArgsForCall, struct {
		arg1 *modelsa.Product
	}{arg1})
	stub := fake.TranslateAPIProductStub
	fakeReturns := fake.translateAPIProductReturns
	fake.recordInvocation("TranslateAPIProduct", []interface{}{arg1})
	fake.translateAPIProductMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPIProductCallCount() int {
	fake.translateAPIProductMutex.RLock()
	defer fake.translateAPIProductMutex.RUnlock()
	return len(fake.translateAPIProductArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPIProductCalls(stub func(*modelsa.Product) *models.Product) {
	fake.translateAPIProductMutex.Lock()
	defer fake.translateAPIProductMutex.Unlock()
	fake.TranslateAPIProductStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPIProductArgsForCall(i int) *modelsa.Product {
	fake.translateAPIProductMutex.RLock()
	defer fake.translateAPIProductMutex.RUnlock()
	argsForCall := fake.translateAPIProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPIProductReturns(result1 *models.Product) {
	fake.translateAPIProductMutex.Lock()
	defer fake.translateAPIProductMutex.Unlock()
	fake.TranslateAPIProductStub = nil
	fake.translateAPIProductReturns = struct {
		result1 *models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIProductReturnsOnCall(i int, result1 *models.Product) {
	fake.translateAPIProductMutex.Lock()
	defer fake.translateAPIProductMutex.Unlock()
	fake.TranslateAPIProductStub = nil
	if fake.translateAPIProductReturnsOnCall == nil {
		fake.translateAPIProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
		})
	}
	fake.translateAPIProductReturnsOnCall[i] = struct {
		result1 *models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIProducts(arg1 []*modelsa.Product) []*models.Product {
	var arg1Copy []*modelsa.Product
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Product, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPIProductsMutex.Lock()
	ret, specificReturn := fake.translateAPIProductsReturnsOnCall[len(fake.translateAPIProductsArgsForCall)]
	fake.translateAPIProductsArgsForCall = append(fake.translateAPIProductsArgsForCall, struct {
		arg1 []*modelsa.Product
	}{arg1Copy})
	stub := fake.TranslateAPIProductsStub
	fakeReturns := fake.translateAPIProductsReturns
	fake.recordInvocation("TranslateAPIProducts", []interface{}{arg1Copy})
	fake.translateAPIProductsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPIProductsCallCount() int {
	fake.translateAPIProductsMutex.RLock()
	defer fake.translateAPIProductsMutex.RUnlock()
	return len(fake.translateAPIProductsArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPIProductsCalls(stub func([]*modelsa.Product) []*models.Product) {
	fake.translateAPIProductsMutex.Lock()
	defer fake.translateAPIProductsMutex.Unlock()
	fake.TranslateAPIProductsStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPIProductsArgsForCall(i int) []*modelsa.Product {
	fake.translateAPIProductsMutex.RLock()
	defer fake.translateAPIProductsMutex.RUnlock()
	argsForCall := fake.translateAPIProductsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPIProductsReturns(result1 []*models.Product) {
	fake.translateAPIProductsMutex.Lock()
	defer fake.translateAPIProductsMutex.Unlock()
	fake.TranslateAPIProductsStub = nil
	fake.translateAPIProductsReturns = struct {
		result1 []*models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPIProductsReturnsOnCall(i int, result1 []*models.Product) {
	fake.translateAPIProductsMutex.Lock()
	defer fake.translateAPIProductsMutex.Unlock()
	fake.TranslateAPIProductsStub = nil
	if fake.translateAPIProductsReturnsOnCall == nil {
		fake.translateAPIProductsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
		})
	}
	fake.translateAPIProductsReturnsOnCall[i] = struct {
		result1 []*models.Product
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPITerpene(arg1 *modelsa.Terpene) *models.Terpene {
	fake.translateAPITerpeneMutex.Lock()
	ret, specificReturn := fake.translateAPITerpeneReturnsOnCall[len(fake.translateAPITerpeneArgsForCall)]
	fake.translateAPITerpeneArgsForCall = append(fake.translateAPITerpeneArgsForCall, struct {
		arg1 *modelsa.Terpene
	}{arg1})
	stub := fake.TranslateAPITerpeneStub
	fakeReturns := fake.translateAPITerpeneReturns
	fake.recordInvocation("TranslateAPITerpene", []interface{}{arg1})
	fake.translateAPITerpeneMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPITerpeneCallCount() int {
	fake.translateAPITerpeneMutex.RLock()
	defer fake.translateAPITerpeneMutex.RUnlock()
	return len(fake.translateAPITerpeneArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPITerpeneCalls(stub func(*modelsa.Terpene) *models.Terpene) {
	fake.translateAPITerpeneMutex.Lock()
	defer fake.translateAPITerpeneMutex.Unlock()
	fake.TranslateAPITerpeneStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPITerpeneArgsForCall(i int) *modelsa.Terpene {
	fake.translateAPITerpeneMutex.RLock()
	defer fake.translateAPITerpeneMutex.RUnlock()
	argsForCall := fake.translateAPITerpeneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPITerpeneReturns(result1 *models.Terpene) {
	fake.translateAPITerpeneMutex.Lock()
	defer fake.translateAPITerpeneMutex.Unlock()
	fake.TranslateAPITerpeneStub = nil
	fake.translateAPITerpeneReturns = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPITerpeneReturnsOnCall(i int, result1 *models.Terpene) {
	fake.translateAPITerpeneMutex.Lock()
	defer fake.translateAPITerpeneMutex.Unlock()
	fake.TranslateAPITerpeneStub = nil
	if fake.translateAPITerpeneReturnsOnCall == nil {
		fake.translateAPITerpeneReturnsOnCall = make(map[int]struct {
			result1 *models.Terpene
		})
	}
	fake.translateAPITerpeneReturnsOnCall[i] = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPITerpenes(arg1 []*modelsa.Terpene) []*models.Terpene {
	var arg1Copy []*modelsa.Terpene
	if arg1 != nil {
		arg1Copy = make([]*modelsa.Terpene, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateAPITerpenesMutex.Lock()
	ret, specificReturn := fake.translateAPITerpenesReturnsOnCall[len(fake.translateAPITerpenesArgsForCall)]
	fake.translateAPITerpenesArgsForCall = append(fake.translateAPITerpenesArgsForCall, struct {
		arg1 []*modelsa.Terpene
	}{arg1Copy})
	stub := fake.TranslateAPITerpenesStub
	fakeReturns := fake.translateAPITerpenesReturns
	fake.recordInvocation("TranslateAPITerpenes", []interface{}{arg1Copy})
	fake.translateAPITerpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPITranslatable) TranslateAPITerpenesCallCount() int {
	fake.translateAPITerpenesMutex.RLock()
	defer fake.translateAPITerpenesMutex.RUnlock()
	return len(fake.translateAPITerpenesArgsForCall)
}

func (fake *FakeAPITranslatable) TranslateAPITerpenesCalls(stub func([]*modelsa.Terpene) []*models.Terpene) {
	fake.translateAPITerpenesMutex.Lock()
	defer fake.translateAPITerpenesMutex.Unlock()
	fake.TranslateAPITerpenesStub = stub
}

func (fake *FakeAPITranslatable) TranslateAPITerpenesArgsForCall(i int) []*modelsa.Terpene {
	fake.translateAPITerpenesMutex.RLock()
	defer fake.translateAPITerpenesMutex.RUnlock()
	argsForCall := fake.translateAPITerpenesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPITranslatable) TranslateAPITerpenesReturns(result1 []*models.Terpene) {
	fake.translateAPITerpenesMutex.Lock()
	defer fake.translateAPITerpenesMutex.Unlock()
	fake.TranslateAPITerpenesStub = nil
	fake.translateAPITerpenesReturns = struct {
		result1 []*models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) TranslateAPITerpenesReturnsOnCall(i int, result1 []*models.Terpene) {
	fake.translateAPITerpenesMutex.Lock()
	defer fake.translateAPITerpenesMutex.Unlock()
	fake.TranslateAPITerpenesStub = nil
	if fake.translateAPITerpenesReturnsOnCall == nil {
		fake.translateAPITerpenesReturnsOnCall = make(map[int]struct {
			result1 []*models.Terpene
		})
	}
	fake.translateAPITerpenesReturnsOnCall[i] = struct {
		result1 []*models.Terpene
	}{result1}
}

func (fake *FakeAPITranslatable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.translateAPICannabinoidMutex.RLock()
	defer fake.translateAPICannabinoidMutex.RUnlock()
	fake.translateAPICannabinoidsMutex.RLock()
	defer fake.translateAPICannabinoidsMutex.RUnlock()
	fake.translateAPICategoriesMutex.RLock()
	defer fake.translateAPICategoriesMutex.RUnlock()
	fake.translateAPICategoryMutex.RLock()
	defer fake.translateAPICategoryMutex.RUnlock()
	fake.translateAPIDispensariesMutex.RLock()
	defer fake.translateAPIDispensariesMutex.RUnlock()
	fake.translateAPIDispensaryMutex.RLock()
	defer fake.translateAPIDispensaryMutex.RUnlock()
	fake.translateAPILocationMutex.RLock()
	defer fake.translateAPILocationMutex.RUnlock()
	fake.translateAPILocationsMutex.RLock()
	defer fake.translateAPILocationsMutex.RUnlock()
	fake.translateAPIOfferMutex.RLock()
	defer fake.translateAPIOfferMutex.RUnlock()
	fake.translateAPIOffersMutex.RLock()
	defer fake.translateAPIOffersMutex.RUnlock()
	fake.translateAPIProductMutex.RLock()
	defer fake.translateAPIProductMutex.RUnlock()
	fake.translateAPIProductsMutex.RLock()
	defer fake.translateAPIProductsMutex.RUnlock()
	fake.translateAPITerpeneMutex.RLock()
	defer fake.translateAPITerpeneMutex.RUnlock()
	fake.translateAPITerpenesMutex.RLock()
	defer fake.translateAPITerpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAPITranslatable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ translation.APITranslatable = new(FakeAPITranslatable)
