// Code generated by counterfeiter. DO NOT EDIT.
package translationfakes

import (
	"sync"

	"github.com/Linkinlog/LeafListr/internal/curaleaf/client"
	"github.com/Linkinlog/LeafListr/internal/models"
	"github.com/Linkinlog/LeafListr/internal/translation"
)

type FakeClientTranslatable struct {
	TranslateClientCannabinoidStub        func(client.CannabinoidObj) *models.Cannabinoid
	translateClientCannabinoidMutex       sync.RWMutex
	translateClientCannabinoidArgsForCall []struct {
		arg1 client.CannabinoidObj
	}
	translateClientCannabinoidReturns struct {
		result1 *models.Cannabinoid
	}
	translateClientCannabinoidReturnsOnCall map[int]struct {
		result1 *models.Cannabinoid
	}
	TranslateClientCannabinoidsStub        func([]client.CannabinoidObj) *models.Cannabinoid
	translateClientCannabinoidsMutex       sync.RWMutex
	translateClientCannabinoidsArgsForCall []struct {
		arg1 []client.CannabinoidObj
	}
	translateClientCannabinoidsReturns struct {
		result1 *models.Cannabinoid
	}
	translateClientCannabinoidsReturnsOnCall map[int]struct {
		result1 *models.Cannabinoid
	}
	TranslateClientCategoriesStub        func([]client.Category) []*models.Category
	translateClientCategoriesMutex       sync.RWMutex
	translateClientCategoriesArgsForCall []struct {
		arg1 []client.Category
	}
	translateClientCategoriesReturns struct {
		result1 []*models.Category
	}
	translateClientCategoriesReturnsOnCall map[int]struct {
		result1 []*models.Category
	}
	TranslateClientCategoryStub        func(client.Category) []*models.Category
	translateClientCategoryMutex       sync.RWMutex
	translateClientCategoryArgsForCall []struct {
		arg1 client.Category
	}
	translateClientCategoryReturns struct {
		result1 []*models.Category
	}
	translateClientCategoryReturnsOnCall map[int]struct {
		result1 []*models.Category
	}
	TranslateClientLocationStub        func(client.Location) *models.Location
	translateClientLocationMutex       sync.RWMutex
	translateClientLocationArgsForCall []struct {
		arg1 client.Location
	}
	translateClientLocationReturns struct {
		result1 *models.Location
	}
	translateClientLocationReturnsOnCall map[int]struct {
		result1 *models.Location
	}
	TranslateClientLocationsStub        func([]client.Location) []*models.Location
	translateClientLocationsMutex       sync.RWMutex
	translateClientLocationsArgsForCall []struct {
		arg1 []client.Location
	}
	translateClientLocationsReturns struct {
		result1 []*models.Location
	}
	translateClientLocationsReturnsOnCall map[int]struct {
		result1 []*models.Location
	}
	TranslateClientOfferStub        func(client.Offer) []*models.Offer
	translateClientOfferMutex       sync.RWMutex
	translateClientOfferArgsForCall []struct {
		arg1 client.Offer
	}
	translateClientOfferReturns struct {
		result1 []*models.Offer
	}
	translateClientOfferReturnsOnCall map[int]struct {
		result1 []*models.Offer
	}
	TranslateClientOffersStub        func([]client.Offer) []*models.Offer
	translateClientOffersMutex       sync.RWMutex
	translateClientOffersArgsForCall []struct {
		arg1 []client.Offer
	}
	translateClientOffersReturns struct {
		result1 []*models.Offer
	}
	translateClientOffersReturnsOnCall map[int]struct {
		result1 []*models.Offer
	}
	TranslateClientProductStub        func(client.Product) *models.Product
	translateClientProductMutex       sync.RWMutex
	translateClientProductArgsForCall []struct {
		arg1 client.Product
	}
	translateClientProductReturns struct {
		result1 *models.Product
	}
	translateClientProductReturnsOnCall map[int]struct {
		result1 *models.Product
	}
	TranslateClientProductsStub        func([]client.Product) []*models.Product
	translateClientProductsMutex       sync.RWMutex
	translateClientProductsArgsForCall []struct {
		arg1 []client.Product
	}
	translateClientProductsReturns struct {
		result1 []*models.Product
	}
	translateClientProductsReturnsOnCall map[int]struct {
		result1 []*models.Product
	}
	TranslateClientTerpeneStub        func(client.TerpeneObj) *models.Terpene
	translateClientTerpeneMutex       sync.RWMutex
	translateClientTerpeneArgsForCall []struct {
		arg1 client.TerpeneObj
	}
	translateClientTerpeneReturns struct {
		result1 *models.Terpene
	}
	translateClientTerpeneReturnsOnCall map[int]struct {
		result1 *models.Terpene
	}
	TranslateClientTerpenesStub        func([]client.TerpeneObj) *models.Terpene
	translateClientTerpenesMutex       sync.RWMutex
	translateClientTerpenesArgsForCall []struct {
		arg1 []client.TerpeneObj
	}
	translateClientTerpenesReturns struct {
		result1 *models.Terpene
	}
	translateClientTerpenesReturnsOnCall map[int]struct {
		result1 *models.Terpene
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoid(arg1 client.CannabinoidObj) *models.Cannabinoid {
	fake.translateClientCannabinoidMutex.Lock()
	ret, specificReturn := fake.translateClientCannabinoidReturnsOnCall[len(fake.translateClientCannabinoidArgsForCall)]
	fake.translateClientCannabinoidArgsForCall = append(fake.translateClientCannabinoidArgsForCall, struct {
		arg1 client.CannabinoidObj
	}{arg1})
	stub := fake.TranslateClientCannabinoidStub
	fakeReturns := fake.translateClientCannabinoidReturns
	fake.recordInvocation("TranslateClientCannabinoid", []interface{}{arg1})
	fake.translateClientCannabinoidMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidCallCount() int {
	fake.translateClientCannabinoidMutex.RLock()
	defer fake.translateClientCannabinoidMutex.RUnlock()
	return len(fake.translateClientCannabinoidArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidCalls(stub func(client.CannabinoidObj) *models.Cannabinoid) {
	fake.translateClientCannabinoidMutex.Lock()
	defer fake.translateClientCannabinoidMutex.Unlock()
	fake.TranslateClientCannabinoidStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidArgsForCall(i int) client.CannabinoidObj {
	fake.translateClientCannabinoidMutex.RLock()
	defer fake.translateClientCannabinoidMutex.RUnlock()
	argsForCall := fake.translateClientCannabinoidArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidReturns(result1 *models.Cannabinoid) {
	fake.translateClientCannabinoidMutex.Lock()
	defer fake.translateClientCannabinoidMutex.Unlock()
	fake.TranslateClientCannabinoidStub = nil
	fake.translateClientCannabinoidReturns = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidReturnsOnCall(i int, result1 *models.Cannabinoid) {
	fake.translateClientCannabinoidMutex.Lock()
	defer fake.translateClientCannabinoidMutex.Unlock()
	fake.TranslateClientCannabinoidStub = nil
	if fake.translateClientCannabinoidReturnsOnCall == nil {
		fake.translateClientCannabinoidReturnsOnCall = make(map[int]struct {
			result1 *models.Cannabinoid
		})
	}
	fake.translateClientCannabinoidReturnsOnCall[i] = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoids(arg1 []client.CannabinoidObj) *models.Cannabinoid {
	var arg1Copy []client.CannabinoidObj
	if arg1 != nil {
		arg1Copy = make([]client.CannabinoidObj, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateClientCannabinoidsMutex.Lock()
	ret, specificReturn := fake.translateClientCannabinoidsReturnsOnCall[len(fake.translateClientCannabinoidsArgsForCall)]
	fake.translateClientCannabinoidsArgsForCall = append(fake.translateClientCannabinoidsArgsForCall, struct {
		arg1 []client.CannabinoidObj
	}{arg1Copy})
	stub := fake.TranslateClientCannabinoidsStub
	fakeReturns := fake.translateClientCannabinoidsReturns
	fake.recordInvocation("TranslateClientCannabinoids", []interface{}{arg1Copy})
	fake.translateClientCannabinoidsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidsCallCount() int {
	fake.translateClientCannabinoidsMutex.RLock()
	defer fake.translateClientCannabinoidsMutex.RUnlock()
	return len(fake.translateClientCannabinoidsArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidsCalls(stub func([]client.CannabinoidObj) *models.Cannabinoid) {
	fake.translateClientCannabinoidsMutex.Lock()
	defer fake.translateClientCannabinoidsMutex.Unlock()
	fake.TranslateClientCannabinoidsStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidsArgsForCall(i int) []client.CannabinoidObj {
	fake.translateClientCannabinoidsMutex.RLock()
	defer fake.translateClientCannabinoidsMutex.RUnlock()
	argsForCall := fake.translateClientCannabinoidsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidsReturns(result1 *models.Cannabinoid) {
	fake.translateClientCannabinoidsMutex.Lock()
	defer fake.translateClientCannabinoidsMutex.Unlock()
	fake.TranslateClientCannabinoidsStub = nil
	fake.translateClientCannabinoidsReturns = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCannabinoidsReturnsOnCall(i int, result1 *models.Cannabinoid) {
	fake.translateClientCannabinoidsMutex.Lock()
	defer fake.translateClientCannabinoidsMutex.Unlock()
	fake.TranslateClientCannabinoidsStub = nil
	if fake.translateClientCannabinoidsReturnsOnCall == nil {
		fake.translateClientCannabinoidsReturnsOnCall = make(map[int]struct {
			result1 *models.Cannabinoid
		})
	}
	fake.translateClientCannabinoidsReturnsOnCall[i] = struct {
		result1 *models.Cannabinoid
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCategories(arg1 []client.Category) []*models.Category {
	var arg1Copy []client.Category
	if arg1 != nil {
		arg1Copy = make([]client.Category, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateClientCategoriesMutex.Lock()
	ret, specificReturn := fake.translateClientCategoriesReturnsOnCall[len(fake.translateClientCategoriesArgsForCall)]
	fake.translateClientCategoriesArgsForCall = append(fake.translateClientCategoriesArgsForCall, struct {
		arg1 []client.Category
	}{arg1Copy})
	stub := fake.TranslateClientCategoriesStub
	fakeReturns := fake.translateClientCategoriesReturns
	fake.recordInvocation("TranslateClientCategories", []interface{}{arg1Copy})
	fake.translateClientCategoriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientCategoriesCallCount() int {
	fake.translateClientCategoriesMutex.RLock()
	defer fake.translateClientCategoriesMutex.RUnlock()
	return len(fake.translateClientCategoriesArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientCategoriesCalls(stub func([]client.Category) []*models.Category) {
	fake.translateClientCategoriesMutex.Lock()
	defer fake.translateClientCategoriesMutex.Unlock()
	fake.TranslateClientCategoriesStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientCategoriesArgsForCall(i int) []client.Category {
	fake.translateClientCategoriesMutex.RLock()
	defer fake.translateClientCategoriesMutex.RUnlock()
	argsForCall := fake.translateClientCategoriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientCategoriesReturns(result1 []*models.Category) {
	fake.translateClientCategoriesMutex.Lock()
	defer fake.translateClientCategoriesMutex.Unlock()
	fake.TranslateClientCategoriesStub = nil
	fake.translateClientCategoriesReturns = struct {
		result1 []*models.Category
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCategoriesReturnsOnCall(i int, result1 []*models.Category) {
	fake.translateClientCategoriesMutex.Lock()
	defer fake.translateClientCategoriesMutex.Unlock()
	fake.TranslateClientCategoriesStub = nil
	if fake.translateClientCategoriesReturnsOnCall == nil {
		fake.translateClientCategoriesReturnsOnCall = make(map[int]struct {
			result1 []*models.Category
		})
	}
	fake.translateClientCategoriesReturnsOnCall[i] = struct {
		result1 []*models.Category
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCategory(arg1 client.Category) []*models.Category {
	fake.translateClientCategoryMutex.Lock()
	ret, specificReturn := fake.translateClientCategoryReturnsOnCall[len(fake.translateClientCategoryArgsForCall)]
	fake.translateClientCategoryArgsForCall = append(fake.translateClientCategoryArgsForCall, struct {
		arg1 client.Category
	}{arg1})
	stub := fake.TranslateClientCategoryStub
	fakeReturns := fake.translateClientCategoryReturns
	fake.recordInvocation("TranslateClientCategory", []interface{}{arg1})
	fake.translateClientCategoryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientCategoryCallCount() int {
	fake.translateClientCategoryMutex.RLock()
	defer fake.translateClientCategoryMutex.RUnlock()
	return len(fake.translateClientCategoryArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientCategoryCalls(stub func(client.Category) []*models.Category) {
	fake.translateClientCategoryMutex.Lock()
	defer fake.translateClientCategoryMutex.Unlock()
	fake.TranslateClientCategoryStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientCategoryArgsForCall(i int) client.Category {
	fake.translateClientCategoryMutex.RLock()
	defer fake.translateClientCategoryMutex.RUnlock()
	argsForCall := fake.translateClientCategoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientCategoryReturns(result1 []*models.Category) {
	fake.translateClientCategoryMutex.Lock()
	defer fake.translateClientCategoryMutex.Unlock()
	fake.TranslateClientCategoryStub = nil
	fake.translateClientCategoryReturns = struct {
		result1 []*models.Category
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientCategoryReturnsOnCall(i int, result1 []*models.Category) {
	fake.translateClientCategoryMutex.Lock()
	defer fake.translateClientCategoryMutex.Unlock()
	fake.TranslateClientCategoryStub = nil
	if fake.translateClientCategoryReturnsOnCall == nil {
		fake.translateClientCategoryReturnsOnCall = make(map[int]struct {
			result1 []*models.Category
		})
	}
	fake.translateClientCategoryReturnsOnCall[i] = struct {
		result1 []*models.Category
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientLocation(arg1 client.Location) *models.Location {
	fake.translateClientLocationMutex.Lock()
	ret, specificReturn := fake.translateClientLocationReturnsOnCall[len(fake.translateClientLocationArgsForCall)]
	fake.translateClientLocationArgsForCall = append(fake.translateClientLocationArgsForCall, struct {
		arg1 client.Location
	}{arg1})
	stub := fake.TranslateClientLocationStub
	fakeReturns := fake.translateClientLocationReturns
	fake.recordInvocation("TranslateClientLocation", []interface{}{arg1})
	fake.translateClientLocationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientLocationCallCount() int {
	fake.translateClientLocationMutex.RLock()
	defer fake.translateClientLocationMutex.RUnlock()
	return len(fake.translateClientLocationArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientLocationCalls(stub func(client.Location) *models.Location) {
	fake.translateClientLocationMutex.Lock()
	defer fake.translateClientLocationMutex.Unlock()
	fake.TranslateClientLocationStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientLocationArgsForCall(i int) client.Location {
	fake.translateClientLocationMutex.RLock()
	defer fake.translateClientLocationMutex.RUnlock()
	argsForCall := fake.translateClientLocationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientLocationReturns(result1 *models.Location) {
	fake.translateClientLocationMutex.Lock()
	defer fake.translateClientLocationMutex.Unlock()
	fake.TranslateClientLocationStub = nil
	fake.translateClientLocationReturns = struct {
		result1 *models.Location
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientLocationReturnsOnCall(i int, result1 *models.Location) {
	fake.translateClientLocationMutex.Lock()
	defer fake.translateClientLocationMutex.Unlock()
	fake.TranslateClientLocationStub = nil
	if fake.translateClientLocationReturnsOnCall == nil {
		fake.translateClientLocationReturnsOnCall = make(map[int]struct {
			result1 *models.Location
		})
	}
	fake.translateClientLocationReturnsOnCall[i] = struct {
		result1 *models.Location
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientLocations(arg1 []client.Location) []*models.Location {
	var arg1Copy []client.Location
	if arg1 != nil {
		arg1Copy = make([]client.Location, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateClientLocationsMutex.Lock()
	ret, specificReturn := fake.translateClientLocationsReturnsOnCall[len(fake.translateClientLocationsArgsForCall)]
	fake.translateClientLocationsArgsForCall = append(fake.translateClientLocationsArgsForCall, struct {
		arg1 []client.Location
	}{arg1Copy})
	stub := fake.TranslateClientLocationsStub
	fakeReturns := fake.translateClientLocationsReturns
	fake.recordInvocation("TranslateClientLocations", []interface{}{arg1Copy})
	fake.translateClientLocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientLocationsCallCount() int {
	fake.translateClientLocationsMutex.RLock()
	defer fake.translateClientLocationsMutex.RUnlock()
	return len(fake.translateClientLocationsArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientLocationsCalls(stub func([]client.Location) []*models.Location) {
	fake.translateClientLocationsMutex.Lock()
	defer fake.translateClientLocationsMutex.Unlock()
	fake.TranslateClientLocationsStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientLocationsArgsForCall(i int) []client.Location {
	fake.translateClientLocationsMutex.RLock()
	defer fake.translateClientLocationsMutex.RUnlock()
	argsForCall := fake.translateClientLocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientLocationsReturns(result1 []*models.Location) {
	fake.translateClientLocationsMutex.Lock()
	defer fake.translateClientLocationsMutex.Unlock()
	fake.TranslateClientLocationsStub = nil
	fake.translateClientLocationsReturns = struct {
		result1 []*models.Location
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientLocationsReturnsOnCall(i int, result1 []*models.Location) {
	fake.translateClientLocationsMutex.Lock()
	defer fake.translateClientLocationsMutex.Unlock()
	fake.TranslateClientLocationsStub = nil
	if fake.translateClientLocationsReturnsOnCall == nil {
		fake.translateClientLocationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Location
		})
	}
	fake.translateClientLocationsReturnsOnCall[i] = struct {
		result1 []*models.Location
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientOffer(arg1 client.Offer) []*models.Offer {
	fake.translateClientOfferMutex.Lock()
	ret, specificReturn := fake.translateClientOfferReturnsOnCall[len(fake.translateClientOfferArgsForCall)]
	fake.translateClientOfferArgsForCall = append(fake.translateClientOfferArgsForCall, struct {
		arg1 client.Offer
	}{arg1})
	stub := fake.TranslateClientOfferStub
	fakeReturns := fake.translateClientOfferReturns
	fake.recordInvocation("TranslateClientOffer", []interface{}{arg1})
	fake.translateClientOfferMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientOfferCallCount() int {
	fake.translateClientOfferMutex.RLock()
	defer fake.translateClientOfferMutex.RUnlock()
	return len(fake.translateClientOfferArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientOfferCalls(stub func(client.Offer) []*models.Offer) {
	fake.translateClientOfferMutex.Lock()
	defer fake.translateClientOfferMutex.Unlock()
	fake.TranslateClientOfferStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientOfferArgsForCall(i int) client.Offer {
	fake.translateClientOfferMutex.RLock()
	defer fake.translateClientOfferMutex.RUnlock()
	argsForCall := fake.translateClientOfferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientOfferReturns(result1 []*models.Offer) {
	fake.translateClientOfferMutex.Lock()
	defer fake.translateClientOfferMutex.Unlock()
	fake.TranslateClientOfferStub = nil
	fake.translateClientOfferReturns = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientOfferReturnsOnCall(i int, result1 []*models.Offer) {
	fake.translateClientOfferMutex.Lock()
	defer fake.translateClientOfferMutex.Unlock()
	fake.TranslateClientOfferStub = nil
	if fake.translateClientOfferReturnsOnCall == nil {
		fake.translateClientOfferReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
		})
	}
	fake.translateClientOfferReturnsOnCall[i] = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientOffers(arg1 []client.Offer) []*models.Offer {
	var arg1Copy []client.Offer
	if arg1 != nil {
		arg1Copy = make([]client.Offer, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateClientOffersMutex.Lock()
	ret, specificReturn := fake.translateClientOffersReturnsOnCall[len(fake.translateClientOffersArgsForCall)]
	fake.translateClientOffersArgsForCall = append(fake.translateClientOffersArgsForCall, struct {
		arg1 []client.Offer
	}{arg1Copy})
	stub := fake.TranslateClientOffersStub
	fakeReturns := fake.translateClientOffersReturns
	fake.recordInvocation("TranslateClientOffers", []interface{}{arg1Copy})
	fake.translateClientOffersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientOffersCallCount() int {
	fake.translateClientOffersMutex.RLock()
	defer fake.translateClientOffersMutex.RUnlock()
	return len(fake.translateClientOffersArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientOffersCalls(stub func([]client.Offer) []*models.Offer) {
	fake.translateClientOffersMutex.Lock()
	defer fake.translateClientOffersMutex.Unlock()
	fake.TranslateClientOffersStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientOffersArgsForCall(i int) []client.Offer {
	fake.translateClientOffersMutex.RLock()
	defer fake.translateClientOffersMutex.RUnlock()
	argsForCall := fake.translateClientOffersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientOffersReturns(result1 []*models.Offer) {
	fake.translateClientOffersMutex.Lock()
	defer fake.translateClientOffersMutex.Unlock()
	fake.TranslateClientOffersStub = nil
	fake.translateClientOffersReturns = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientOffersReturnsOnCall(i int, result1 []*models.Offer) {
	fake.translateClientOffersMutex.Lock()
	defer fake.translateClientOffersMutex.Unlock()
	fake.TranslateClientOffersStub = nil
	if fake.translateClientOffersReturnsOnCall == nil {
		fake.translateClientOffersReturnsOnCall = make(map[int]struct {
			result1 []*models.Offer
		})
	}
	fake.translateClientOffersReturnsOnCall[i] = struct {
		result1 []*models.Offer
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientProduct(arg1 client.Product) *models.Product {
	fake.translateClientProductMutex.Lock()
	ret, specificReturn := fake.translateClientProductReturnsOnCall[len(fake.translateClientProductArgsForCall)]
	fake.translateClientProductArgsForCall = append(fake.translateClientProductArgsForCall, struct {
		arg1 client.Product
	}{arg1})
	stub := fake.TranslateClientProductStub
	fakeReturns := fake.translateClientProductReturns
	fake.recordInvocation("TranslateClientProduct", []interface{}{arg1})
	fake.translateClientProductMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientProductCallCount() int {
	fake.translateClientProductMutex.RLock()
	defer fake.translateClientProductMutex.RUnlock()
	return len(fake.translateClientProductArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientProductCalls(stub func(client.Product) *models.Product) {
	fake.translateClientProductMutex.Lock()
	defer fake.translateClientProductMutex.Unlock()
	fake.TranslateClientProductStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientProductArgsForCall(i int) client.Product {
	fake.translateClientProductMutex.RLock()
	defer fake.translateClientProductMutex.RUnlock()
	argsForCall := fake.translateClientProductArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientProductReturns(result1 *models.Product) {
	fake.translateClientProductMutex.Lock()
	defer fake.translateClientProductMutex.Unlock()
	fake.TranslateClientProductStub = nil
	fake.translateClientProductReturns = struct {
		result1 *models.Product
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientProductReturnsOnCall(i int, result1 *models.Product) {
	fake.translateClientProductMutex.Lock()
	defer fake.translateClientProductMutex.Unlock()
	fake.TranslateClientProductStub = nil
	if fake.translateClientProductReturnsOnCall == nil {
		fake.translateClientProductReturnsOnCall = make(map[int]struct {
			result1 *models.Product
		})
	}
	fake.translateClientProductReturnsOnCall[i] = struct {
		result1 *models.Product
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientProducts(arg1 []client.Product) []*models.Product {
	var arg1Copy []client.Product
	if arg1 != nil {
		arg1Copy = make([]client.Product, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateClientProductsMutex.Lock()
	ret, specificReturn := fake.translateClientProductsReturnsOnCall[len(fake.translateClientProductsArgsForCall)]
	fake.translateClientProductsArgsForCall = append(fake.translateClientProductsArgsForCall, struct {
		arg1 []client.Product
	}{arg1Copy})
	stub := fake.TranslateClientProductsStub
	fakeReturns := fake.translateClientProductsReturns
	fake.recordInvocation("TranslateClientProducts", []interface{}{arg1Copy})
	fake.translateClientProductsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientProductsCallCount() int {
	fake.translateClientProductsMutex.RLock()
	defer fake.translateClientProductsMutex.RUnlock()
	return len(fake.translateClientProductsArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientProductsCalls(stub func([]client.Product) []*models.Product) {
	fake.translateClientProductsMutex.Lock()
	defer fake.translateClientProductsMutex.Unlock()
	fake.TranslateClientProductsStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientProductsArgsForCall(i int) []client.Product {
	fake.translateClientProductsMutex.RLock()
	defer fake.translateClientProductsMutex.RUnlock()
	argsForCall := fake.translateClientProductsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientProductsReturns(result1 []*models.Product) {
	fake.translateClientProductsMutex.Lock()
	defer fake.translateClientProductsMutex.Unlock()
	fake.TranslateClientProductsStub = nil
	fake.translateClientProductsReturns = struct {
		result1 []*models.Product
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientProductsReturnsOnCall(i int, result1 []*models.Product) {
	fake.translateClientProductsMutex.Lock()
	defer fake.translateClientProductsMutex.Unlock()
	fake.TranslateClientProductsStub = nil
	if fake.translateClientProductsReturnsOnCall == nil {
		fake.translateClientProductsReturnsOnCall = make(map[int]struct {
			result1 []*models.Product
		})
	}
	fake.translateClientProductsReturnsOnCall[i] = struct {
		result1 []*models.Product
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientTerpene(arg1 client.TerpeneObj) *models.Terpene {
	fake.translateClientTerpeneMutex.Lock()
	ret, specificReturn := fake.translateClientTerpeneReturnsOnCall[len(fake.translateClientTerpeneArgsForCall)]
	fake.translateClientTerpeneArgsForCall = append(fake.translateClientTerpeneArgsForCall, struct {
		arg1 client.TerpeneObj
	}{arg1})
	stub := fake.TranslateClientTerpeneStub
	fakeReturns := fake.translateClientTerpeneReturns
	fake.recordInvocation("TranslateClientTerpene", []interface{}{arg1})
	fake.translateClientTerpeneMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientTerpeneCallCount() int {
	fake.translateClientTerpeneMutex.RLock()
	defer fake.translateClientTerpeneMutex.RUnlock()
	return len(fake.translateClientTerpeneArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientTerpeneCalls(stub func(client.TerpeneObj) *models.Terpene) {
	fake.translateClientTerpeneMutex.Lock()
	defer fake.translateClientTerpeneMutex.Unlock()
	fake.TranslateClientTerpeneStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientTerpeneArgsForCall(i int) client.TerpeneObj {
	fake.translateClientTerpeneMutex.RLock()
	defer fake.translateClientTerpeneMutex.RUnlock()
	argsForCall := fake.translateClientTerpeneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientTerpeneReturns(result1 *models.Terpene) {
	fake.translateClientTerpeneMutex.Lock()
	defer fake.translateClientTerpeneMutex.Unlock()
	fake.TranslateClientTerpeneStub = nil
	fake.translateClientTerpeneReturns = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientTerpeneReturnsOnCall(i int, result1 *models.Terpene) {
	fake.translateClientTerpeneMutex.Lock()
	defer fake.translateClientTerpeneMutex.Unlock()
	fake.TranslateClientTerpeneStub = nil
	if fake.translateClientTerpeneReturnsOnCall == nil {
		fake.translateClientTerpeneReturnsOnCall = make(map[int]struct {
			result1 *models.Terpene
		})
	}
	fake.translateClientTerpeneReturnsOnCall[i] = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientTerpenes(arg1 []client.TerpeneObj) *models.Terpene {
	var arg1Copy []client.TerpeneObj
	if arg1 != nil {
		arg1Copy = make([]client.TerpeneObj, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.translateClientTerpenesMutex.Lock()
	ret, specificReturn := fake.translateClientTerpenesReturnsOnCall[len(fake.translateClientTerpenesArgsForCall)]
	fake.translateClientTerpenesArgsForCall = append(fake.translateClientTerpenesArgsForCall, struct {
		arg1 []client.TerpeneObj
	}{arg1Copy})
	stub := fake.TranslateClientTerpenesStub
	fakeReturns := fake.translateClientTerpenesReturns
	fake.recordInvocation("TranslateClientTerpenes", []interface{}{arg1Copy})
	fake.translateClientTerpenesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClientTranslatable) TranslateClientTerpenesCallCount() int {
	fake.translateClientTerpenesMutex.RLock()
	defer fake.translateClientTerpenesMutex.RUnlock()
	return len(fake.translateClientTerpenesArgsForCall)
}

func (fake *FakeClientTranslatable) TranslateClientTerpenesCalls(stub func([]client.TerpeneObj) *models.Terpene) {
	fake.translateClientTerpenesMutex.Lock()
	defer fake.translateClientTerpenesMutex.Unlock()
	fake.TranslateClientTerpenesStub = stub
}

func (fake *FakeClientTranslatable) TranslateClientTerpenesArgsForCall(i int) []client.TerpeneObj {
	fake.translateClientTerpenesMutex.RLock()
	defer fake.translateClientTerpenesMutex.RUnlock()
	argsForCall := fake.translateClientTerpenesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientTranslatable) TranslateClientTerpenesReturns(result1 *models.Terpene) {
	fake.translateClientTerpenesMutex.Lock()
	defer fake.translateClientTerpenesMutex.Unlock()
	fake.TranslateClientTerpenesStub = nil
	fake.translateClientTerpenesReturns = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeClientTranslatable) TranslateClientTerpenesReturnsOnCall(i int, result1 *models.Terpene) {
	fake.translateClientTerpenesMutex.Lock()
	defer fake.translateClientTerpenesMutex.Unlock()
	fake.TranslateClientTerpenesStub = nil
	if fake.translateClientTerpenesReturnsOnCall == nil {
		fake.translateClientTerpenesReturnsOnCall = make(map[int]struct {
			result1 *models.Terpene
		})
	}
	fake.translateClientTerpenesReturnsOnCall[i] = struct {
		result1 *models.Terpene
	}{result1}
}

func (fake *FakeClientTranslatable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.translateClientCannabinoidMutex.RLock()
	defer fake.translateClientCannabinoidMutex.RUnlock()
	fake.translateClientCannabinoidsMutex.RLock()
	defer fake.translateClientCannabinoidsMutex.RUnlock()
	fake.translateClientCategoriesMutex.RLock()
	defer fake.translateClientCategoriesMutex.RUnlock()
	fake.translateClientCategoryMutex.RLock()
	defer fake.translateClientCategoryMutex.RUnlock()
	fake.translateClientLocationMutex.RLock()
	defer fake.translateClientLocationMutex.RUnlock()
	fake.translateClientLocationsMutex.RLock()
	defer fake.translateClientLocationsMutex.RUnlock()
	fake.translateClientOfferMutex.RLock()
	defer fake.translateClientOfferMutex.RUnlock()
	fake.translateClientOffersMutex.RLock()
	defer fake.translateClientOffersMutex.RUnlock()
	fake.translateClientProductMutex.RLock()
	defer fake.translateClientProductMutex.RUnlock()
	fake.translateClientProductsMutex.RLock()
	defer fake.translateClientProductsMutex.RUnlock()
	fake.translateClientTerpeneMutex.RLock()
	defer fake.translateClientTerpeneMutex.RUnlock()
	fake.translateClientTerpenesMutex.RLock()
	defer fake.translateClientTerpenesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClientTranslatable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ translation.ClientTranslatable = new(FakeClientTranslatable)
